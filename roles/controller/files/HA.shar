# HA package built Tue May 31 12:10:33 2016
if echo '
' | od -b | grep -q 015 ; then echo dos format script - exiting ; exit 0 ; fi ; true
# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	appdcontroller-db.sh
#	appdcontroller.sh
#
echo x - appdcontroller-db.sh
sed 's/^X//' >appdcontroller-db.sh << 'END-of-appdcontroller-db.sh'
X#!/bin/bash
X### BEGIN INIT INFO
X# Provides:          appdcontroller-db
X# Required-Start:    $remote_fs $syslog
X# Required-Stop:     $remote_fs $syslog
X# Should-Start:      zfs
X# Should-Stop:       zfs
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Short-Description: AppDynamics Controller
X# Description:       This script starts and stops the AppDynamics Controller
X#                    Database, appserver, and HA components.
X### END INIT INFO
X#
X# $Id: appdcontroller-db.sh 1.10 2016-05-17 22:40:47 rob.navarro $
X# 
X# HA Aware Init file for AppDynamics Controller 
X# 
X# chkconfig: 2345 60 25 
X# description: Controller for AppDynamics
X#
X# assumes that the appdynamics controller and database run as the user 
X# specified in the db.cnf file
X#
X# edit this manually if it hasn't been automatically set by the install-init.sh
X# script
X#
X
X# Setting PATH to just a few trusted directories is an **important security** requirement
XPATH=/bin:/usr/bin:/sbin:/usr/sbin
X
XNAME=$(basename $(readlink -e $0))
X
XAPPD_ROOT=/opt/AppDynamics/Controller
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
XEVENTS_SERVICE_VMOPTIONS_FILE=$APPD_ROOT/events_service/conf/events-service.vmoptions
X[[ -r $EVENTS_SERVICE_VMOPTIONS_FILE ]] || EVENTS_SERVICE_VMOPTIONS_FILE=$APPD_ROOT/events_service/analytics-processor/conf/analytics-processor.vmoptions
XRUNUSER=root
X
X########## START of embedded hafunctions.sh ##########
X#!/bin/bash
X#
X# $Id: hafunctions.sh 1.3 2016-05-17 22:48:38 rob.navarro $
X#
X# hafunctions.sh
X# contains common code used by the HA toolkit
X# 
X###############################################################################
X#
X# IMPORTANT - 	add function names to "export -f" list at bottom of this file
X#              	that should be callable by sub-shells. Any function not so added
X#	 	will not be visible to any sub-shells e.g. $(...), pipelines etc.
X#
X###############################################################################
X
Xfunction err {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "ERROR: $PROGNAME: $*" 1>&2
X        exit 1
X}
X
Xfunction warn {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "WARNING: $PROGNAME: $*" 1>&2
X}
X
X# Helper function to entirely encapsulate variable substitution logic applied to Init
X# scripts during installation.
X# Uses global variables: APPD_ROOT RUNUSER MA_install_dir
X# Call as:
X#   convert_init_script $infile > $outfile
Xfunction convert_init_script {
X        (( $# == 1 )) || err "convert_init_script: needs 1 arg"
X        local infile=$1
X
X        [[ -f $infile ]] || err "convert_init_script: unable to read '$infile'"
X        sed < $infile \
X                -e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X                -e "/^RUNUSER=/s,=.*,=$RUNUSER," \
X                -e "/^MACHINE_AGENT_HOME=/s,=.*,=$MA_install_dir,"
X}
X
X#
X# Collection of routines to deal with MySQL root password
X#
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa1 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa1 <data>
Xfunction obf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(tr '\!-~' 'P-~\!-O' < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 obfuscation"
X	obf=$(base64 -w 0 < <(echo -n $step1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa1 <data>
Xfunction deobf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(base64 -d -w 0 < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 deobfuscation"
X	clear=$(tr '\!-~' 'P-~\!-O' < <(echo -n $step1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa2 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa2 <data>
Xfunction obf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	obf=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa2 <data>
Xfunction deobf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	clear=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# overall wrapper function for obfuscation 
X# Call as
X#  obfuscate <obf type> <data>
X# or
X#  obfuscate <data>
Xfunction obfuscate {
X	(( $# == 1 || $# == 2 )) || err "Usage: ${FUNCNAME[0]} [<obf type>] <data>"
X
X	local thisfn=${FUNCNAME[0]} data otype
X	if (( $# == 2 )) ; then
X		otype=$1
X		data=$2
X	else
X		otype=''
X		data=$1
X	fi
X	case $otype in
X		ofa1 | '' )	obf_ofa1 $data ;;	# default case
X		ofa2)		obf_ofa2 $data ;;
X		*)		err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X# overall wrapper for various de-obfuscator functions
X# Call as:
X#  deobfuscate <otype> <obf_data>
Xfunction deobfuscate {
X	(( $# == 2 )) || err "Usage: ${FUNCNAME[0]} <obf type> <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} otype=$1 data=$2
X	case $otype in
X		ofa1)	deobf_ofa1 "$data" ;;
X		ofa2)	deobf_ofa2 "$data" ;;
X		*)	err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X###
X
X# with help from:
X# http://stackoverflow.com/questions/1923435/how-do-i-echo-stars-when-reading-password-with-read
Xfunction getpw { 
X        (( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <variable name>"
X        local pwch inpw1 inpw2=' ' prompt; 
X        
X        ref=$1 
X	while [[ "$inpw1" != "$inpw2" ]] ; do
X		prompt="Enter MySQL root password: "
X		inpw1=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw1+=$pwch 
X			fi 
X		done 
X
X		prompt="re-enter same password: "
X		inpw2=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw2+=$pwch 
X			fi 
X		done 
X	
X		[[ "$inpw1" == "$inpw2" ]] || echo "passwords unequal. Retry..." 1>&2
X	done
X
X	# indirect assignment (without local -n) needs eval. 
X	# This only works with global variables :-( Please use weird variable names to
X	# avoid namespace conflicts...
X        eval "${ref}=\$inpw1"            # assign passwd to parameter variable
X}
X
X# helper function to allow separate setting of passwd from command line.
X# Use this to persist an obfuscated version of the MySQL passwd to disk.
X# Call as:
X#  . hafunctions.sh
X#  save_mysql_passwd $APPD_ROOT
Xfunction save_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	getpw __inpw1 || exit 1		# updates __inpw1 *ONLY* if global variable
X	obf=$(obfuscate $__inpw1) || exit 1
X	echo $obf > $rootpw_obf || err "$thisfn: failed to save obfuscated passwd to $rootpw_obf"
X	chmod 600 $rootpw_obf || warn "$thisfn: failed to make $rootpw_obf readonly"
X}
X
X# get MySQL root password in a variety of ways. Implement the concept:
X# 1. respect MYSQL_ROOT_PASSWD if present; please pass down to sub-scripts. Do NOT persist to disk.
X# 2. respect $APPD_ROOT/db/.rootpw if present
X# 3. respect $APPD_ROOT/db/.rootpw.obf if present
X# 4. otherwise get MySQL root passwd from command line, obfuscate and persist to $APPD_ROOT/db/.rootpw.obf
X#
X# Call as:
X#  $dbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xfunction get_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 clear obf otype inpw2=' '
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw="$APPD_ROOT/db/.rootpw" rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	if [[ -n "$MYSQL_ROOT_PASSWD" ]] ; then
X		echo $MYSQL_ROOT_PASSWD
X	elif [[ -s $rootpw && -r $rootpw ]] ; then 
X		echo $(<$rootpw)
X	elif [[ -s $rootpw_obf ]] ; then
X		IFS=$' ' read -r otype obf < $rootpw_obf
X		[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X		clear=$(deobfuscate $otype $obf) || exit 1
X		[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X		echo $clear
X	else
X		# if STDIN/STDOUT open & connected to a terminal - ie not run as a service, daemon or over ssh
X		if [[ -t 0 && -t 1 ]] ; then
X			save_mysql_passwd $APPD_ROOT			# but save writes directly to disk 
X			IFS=$' ' read -r otype obf < $rootpw_obf	# so need to read back in...
X			[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X			clear=$(deobfuscate $otype $obf) || exit 1
X			[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X			echo $clear
X		else				# give up with an error
X			local RUNUSER=$(awk -F= '$1=="user" { print $2  }' $APPD_ROOT/db/db.cnf)
X			[[ -n "$RUNUSER" ]] || RUNUSER=MySQL
X			err "$thisfn: unable to get MySQL root passwd. As $RUNUSER user run \"(cd HA;. hafunctions.sh;save_mysql_passwd \$(pwd)/..)\" interactively and try again."
X		fi
X	fi
X}
X
X# because there is currently no single program guaranteed to run before using the other scripts
X# we need each script to be able to check whether MySQL root passwd has been set or not.
X# LATER: This can be fixed in future with a self-extracting archive that includes install logic. 
X# Call as:
X#  check_for_mysql_passwd $APPD_ROOT || exit 1
Xfunction check_for_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	get_mysql_passwd $1 >/dev/null 
X}
X
X# make-do function that ignores junk header of controller.sh login-db output that precedes the
X# actual mysql client output and outputs the 1 chosen line requested. This became necessary
X# as folk chose to follow mysql client output with extraneous newline. 
X# Replace 'controller.sh login-db | tail -1' with 'controller.sh login-db | getsqlrow 2'
X# Will be obsolete once clean mysql client output is provided.
X#
X# Call as:
X#  SQLval=$(bin/controller.sh login-db | getsqlrow 2)
Xfunction getsqlrow {
X	(( $# == 1 )) && [[ $1 =~ ^[[:digit:]]+$ ]] || err "Usage: ${FUNCNAME[0]} <mysql client output row #>" || exit 1
X
X   	local LINE pattern='^Logging into the controller database' skiprows
X   	while read -r LINE ; do
X		if [[ $LINE =~ $pattern ]] ; then
X			for (( skiprows=1; skiprows<=$1; ++skiprows )); do 
X				IFS= read -r LINE || return
X	   		done
X	   		echo $LINE		# or preserve leading whitespace with "$LINE"
X			return
X		fi
X   	done
X}
X
X# replacement for calling 'controller.sh login-db' that is guaranteed to only output what 
X# underlying mysql client does. This makes it much easier to reliably parse.
X# Call as:
X#  VAL=$(echo "some SQL" | mysqlclient $APPD_ROOT | grep -q "active")
Xfunction mysqlclient {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <controller install directory>"
X
X	local APPD_ROOT=$1
X	[[ -n "$MYSQL_ROOT_PASSWD" ]] || MYSQL_ROOT_PASSWD=$(get_mysql_passwd $APPD_ROOT) || exit 1
X  	[[ -n "$DB_PORT" ]] || DB_PORT=$(awk -F= '$1=="port" { print $2  }' $APPD_ROOT/db/db.cnf) || exit 1
X	[[ -n "$DB_PORT" ]] || err "${FUNCNAME[0]}: unable to read MySQL port number from $APPD_ROOT/db/db.cnf"
X
X	$APPD_ROOT/db/bin/mysql -A -u root -p"${MYSQL_ROOT_PASSWD}" --port=$DB_PORT --protocol=TCP controller
X}
X
X###############################################################################
X#
X# FOOTER block
X#
X# IMPORTANT  - add function names here which should be callable by sub-shells
X#
X###############################################################################
Xexport -f err warn getpw obf_ofa1 obf_ofa2 obfuscate
Xexport -f mysqlclient get_mysql_passwd save_mysql_passwd deobfuscate deobf_ofa1 deobf_ofa2
X
X########## END of embedded hafunctions.sh ##########
X
Xif [ `id -un` == $RUNUSER ] ; then
X        function runuser {
X                $*
X        }
Xelse
X        function runuser {
X                su -m -s /bin/bash -c "$*" $RUNUSER
X        }
Xfi
X
Xif runuser [ ! -f $APPD_ROOT/db/db.cnf ] ; then
X	echo appd controller not installed in $APPD_ROOT
X	exit 1
Xfi
X
XDB_CNF=/tmp/db.cnf.$$
Xfunction cleanup() {
X	rm -f $DB_CNF
X}
Xtrap cleanup EXIT
X
Xcleanup
Xrunuser cat $APPD_ROOT/db/db.cnf > $DB_CNF
X
XOPEN_FD_LIMIT=`awk -F= '/^[\t ]*open_files_limit=/{print $2; exit}' $DB_CNF`
Xif [ "$OPEN_FD_LIMIT" -lt 65536 ]; then
X	OPEN_FD_LIMIT=65536
Xfi
X
X#
X# Create (touch) a file called LARGE_PAGES_ENABLE in $APPD_ROOT/HA
X# to enable explicit huge pages support for mysqld and java.
X#
X# If other programs on this system are also using huge pages,
X# Please add the appdynamics runtime user to the group specified by
X# /proc/sys/vm/hugetlb_shm_group
X#
X# If AppDynamics is the only application on this host using huge pages,
X# /proc/sys/vm/hugetlb_shm_group will be updated automatically.
X# See https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
X# for more information.
X#
XENABLE_HUGE_PAGES="false"
XHUGE_PAGE_SIZE_BYTES=`awk '/Hugepagesize:/{print $2*1024}' /proc/meminfo`
X
Xif [ -f $APPD_ROOT/HA/LARGE_PAGES_ENABLE ] ; then
X	ENABLE_HUGE_PAGES="true"
Xfi
X
XAPPD_BIN="$APPD_ROOT/bin"
Xlockfile=/var/lock/subsys/$NAME
X[ -d /var/lock/subsys ] || mkdir /var/lock/subsys
X
Xfunction require_root {
X	if [ `id -un` != "root" ] ; then
X		echo "service changes must be run as root"
X		exit 1
X	fi
X}
X
X#
X# trivial sanity check
X#
Xif runuser [ ! -x $APPD_BIN/controller.sh ] ; then
X	echo controller disabled on this host
X	exit 1
Xfi
X
Xfunction enable_pam_limits() {
X	if [ -f /etc/pam.d/common-session ] && \
X		! grep  -Eq "^[\t ]*session[\t ]+required[\t ]+pam_limits\.so" /etc/pam.d/common-session ; then
X		echo "session required	pam_limits.so" >> /etc/pam.d/common-session
X	elif [ -f /etc/pam.d/system-auth ] && \
X		! grep  -Eq "^[\t ]*session[\t ]+required[\t ]+pam_limits\.so" /etc/pam.d/system-auth ; then
X		echo "session required	pam_limits.so" >> /etc/pam.d/system-auth
X	fi
X}
X
X# always make sure this gets called before any other functions that modify
X# /etc/security/limits.d/appdynamics.com, i.e. reserve_memory()
Xfunction set_open_fd_limits() {
X	if [ "$RUNUSER" == "root" ] && [[ `ulimit -S -n` -lt $OPEN_FD_LIMIT ]]
X		then
X		ulimit -n $OPEN_FD_LIMIT
X	elif [[ `su -s /bin/bash -c "ulimit -S -n" $RUNUSER` -lt "$OPEN_FD_LIMIT" ]]
X		then
X		echo "$RUNUSER  soft  nofile $OPEN_FD_LIMIT" > /etc/security/limits.d/appdynamics.conf
X		echo "$RUNUSER  hard  nofile $OPEN_FD_LIMIT" >> /etc/security/limits.d/appdynamics.conf
X		enable_pam_limits
X	fi
X}
X
Xfunction db_running() {
X	DB_PID_FILE=`cat $DB_CNF | grep "^[\t ]*pid-file" | cut -d = -f 2`
X	DB_DATA_DIR=`cat $DB_CNF | grep "^[\t ]*datadir" | cut -d = -f 2`
X	if [ -z "$DB_PID_FILE" ] ; then
X		DB_PID_FILE="$DB_DATA_DIR/$(hostname).pid"
X	fi
X	if [ -z "$DB_PID_FILE" ] ; then
X		return 1
X	fi
X	DB_PID=`runuser cat $DB_PID_FILE 2>/dev/null`
X	if [ -z "$DB_PID" ] ; then
X		return 1
X	fi
X	if [ -d /proc/$DB_PID ] ; then
X		return 0;
X	fi
X	return 1	
X}
X
Xfunction replication_disabled() {
X	if cat $DB_CNF | grep -q "^[\t ]*skip-slave-start=true" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction active() {
X	if echo select value from global_configuration_local \
X			where "name='appserver.mode'" | \
X		runuser mysqlclient $APPD_ROOT | \
X		tail -1 | grep -q "active" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction host_crash(){
X	local lockfile_age=$(($(date +%s)-$(ls -l --time-style=+%s $lockfile | cut -d \  -f 6)))
X	local uptime=$(printf '%.0f\n' $(cat /proc/uptime | cut -d \  -f 1))
X	[ "$lockfile_age" -gt "$uptime" ]
X}
X
Xfunction calculate_memory(){
X	JVM_OPTIONS=`echo "cat /domain/configs/config[@name='server-config']/java-config/jvm-options" | runuser xmllint --shell $DOMAIN_XML`
X	
X	# multiply by 1.05 and round to account for extra 2% allocation overhead +
X	#  headroom
X	CONTROLLER_HEAP=`echo "$JVM_OPTIONS" | awk '/-Xmx/{
X		gsub(/<\/?jvm-options>(-Xmx)?/,"")
X			if(sub(/[k,K]$/,"")==1){ 
X				BYTES=$0*1024 
X			}
X			else if(sub(/[m,M]$/,"")==1){ 
X				BYTES=$0*1048576 
X			}
X			else if(sub(/[g,G]$/,"")==1){ 
X				BYTES=$0*1073741824 
X			} else { 
X				gsub(/[^0-9]/,"") 
X				BYTES=$0 
X			} 
X		}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X		
X	#Parse controller JVM OPTIONS to get MaxPermSize
X	CONTROLLER_MAXPERMSIZE=`echo "$JVM_OPTIONS" | awk '/-XX:MaxPermSize=/{
X		gsub(/<\/?jvm-options>(-XX:MaxPermSize=)?/,"")
X			if(sub(/[k,K]$/,"")==1){ 
X				BYTES=$0*1024 
X			}
X			else if(sub(/[m,M]$/,"")==1){ 
X				BYTES=$0*1048576 
X			}
X			else if(sub(/[g,G]$/,"")==1){ 
X				BYTES=$0*1073741824 
X			} else { 
X				gsub(/[^0-9]/,"") 
X				BYTES=$0 
X			} 
X		}
X		END{print BYTES}'`
X
X	# multiplying by 1.1 and rounding in awk to account for the extra
X	# memory MySQL allocates arround the InnoDB buffer pool.
X	INNODB_BUFFER_POOL=`cat $DB_CNF | \
X		awk -F= '/^[\t ]*innodb_buffer_pool_size/{ 
X		if(sub(/[K][\t ]*$/,"",$2)==1){
X			BYTES=$2*1024
X		}
X		else if(sub(/[M][\t ]*$/,"",$2)==1){
X			BYTES=$2*1048576
X		}
X		else if(sub(/[G][\t ]*$/,"",$2)==1){
X			BYTES=$2*1073741824 
X		} else {
X			gsub(/[^0-9]/,"",$2) 
X			BYTES=$2
X		}
X		BYTES=BYTES*1.1
X		printf("%.0f\n", BYTES)
X		exit; 
X	}'`
X	
X	INNODB_ADDITIONAL_MEM=`cat $DB_CNF | \
X		awk -F= '/^[\t ]*innodb_additional_mem_pool_size=/{ 
X		if(sub(/[K][\t ]*$/,"",$2)==1){
X			BYTES=$2*1024
X		}
X		else if(sub(/[M][\t ]*$/,"",$2)==1){
X			BYTES=$2*1048576
X		}
X		else if(sub(/[G][\t ]*$/,"",$2)==1){
X			BYTES=$2*1073741824
X		} else {
X			gsub(/[^0-9]/,"",$2)
X			BYTES=$2
X		}
X			print BYTES;
X		exit;
X	}'`
X	
X	# multiply by 1.05 and round to account for extra 2% allocation overhead +
X	#  headroom
X	EVENTS_SERVICE_HEAP=`( runuser cat $APPD_ROOT/bin/controller.sh ) \
X		| awk -F= '/^[\t ]*EVENTS_SERVICE_HEAP_SETTINGS=/{
X			$0=substr($2, match($2,/-Xmx[1-9][0-9]*[k,K,m,M,g,G]?/), RLENGTH)
X			sub(/^-Xmx/,"")
X				if(sub(/[k,K]$/,"")==1){
X					BYTES=$0*1024
X				}
X				else if(sub(/[m,M]$/,"")==1){
X					BYTES=$0*1048576
X				}
X				else if(sub(/[g,G]$/,"")==1){
X					BYTES=$0*1073741824
X				} else {
X					gsub(/[^0-9]/,"")
X					BYTES=$0
X				}
X			}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X	
X	if [ -z "$EVENTS_SERVICE_HEAP" ] ; then
X		EVENTS_SERVICE_HEAP=`( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| awk '/^[\t ]*-Xmx[1-9][0-9]*[k,K,m,M,g,G]?/{
X				sub(/^-Xmx/,"")
X					if(sub(/[k,K][\t ]*$/,"")==1){
X						BYTES=$0*1024
X					}
X					else if(sub(/[m,M][\t ]*$/,"")==1){
X						BYTES=$0*1048576
X					}
X					else if(sub(/[g,G][\t ]*$/,"")==1){
X						BYTES=$0*1073741824
X					} else {
X						gsub(/[^0-9]/,"")
X						BYTES=$0
X					}
X				}
X			END{
X				BYTES=BYTES*1.05
X				printf("%.0f\n", BYTES)
X			}'`
X	fi
X
X	if [ -z "$EVENTS_SERVICE_HEAP" ] ; then
X		EVENTS_SERVICE_HEAP=0
X	fi
X		
X	# Parse events service JVM options for MaxPermSize.  Default to 64M if not set
X	EVENTS_SERVICE_MAXPERMSIZE=`( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X		| awk '/^[\t ]*-XX:MaxPermSize=[1-9][0-9]*[k,K,m,M,g,G]?/{
X			sub(/^[\t ]*-XX:MaxPermSize=/,"")
X				if(sub(/[k,K][\t ]*$/,"")==1){
X					BYTES=$0*1024
X				}
X				else if(sub(/[m,M][\t ]*$/,"")==1){
X					BYTES=$0*1048576
X				}
X				else if(sub(/[g,G][\t ]*$/,"")==1){
X					BYTES=$0*1073741824
X				} else {
X					gsub(/[^0-9]/,"")
X					BYTES=$0
X				}
X			}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X		
X	if [ "$EVENTS_SERVICE_MAXPERMSIZE" -lt 1 ] ; then
X		# Java permsize defaults to 64MiB
X		EVENTS_SERVICE_MAXPERMSIZE=67108864
X	fi
X	
X	((APPD_TOTAL_RESERVED_BYTES=\
XCONTROLLER_HEAP+\
XCONTROLLER_MAXPERMSIZE+\
XINNODB_BUFFER_POOL+\
XINNODB_ADDITIONAL_MEM+\
XEVENTS_SERVICE_HEAP+\
XEVENTS_SERVICE_MAXPERMSIZE))
X	
X	((APPD_HUGE_PAGES=APPD_TOTAL_RESERVED_BYTES/HUGE_PAGE_SIZE_BYTES))
X	if [ $((APPD_TOTAL_RESERVED_BYTES%HUGE_PAGE_SIZE_BYTES)) -gt 0 ]
X		then
X		# Round up
X		((APPD_HUGE_PAGES++))
X	fi
X	
X	PAGE_SIZE_BYTES=`getconf PAGE_SIZE`
X}
X
X#
X# Explicitly reserve memory for major contorller components
X#
Xfunction reserve_memory (){
X	# set swappiness to 1 after (CORE-68175):
X	# https://www.percona.com/blog/2014/04/28/oom-relation-vm-swappiness0-new-kernel/
X	# and
X	# https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html
X	echo 1 > /proc/sys/vm/swappiness
X	
X	calculate_memory
X
X	#
X	# If zfs is running on this host
X	# Carve room for controller heap, innodb_buffer_pool_size and
X	# innodb_additional_mem_pool_size.  Leave 20% system RAM uncommitted.
X	#
X
X	TOTAL_RESERVABLE_MEM=`free -b | awk '/Mem:/{RESERVABLE_MEM=$2*0.8; printf("%.0f\n", RESERVABLE_MEM)}'`
X	(( REQ_ZFS_ARC_MAX=TOTAL_RESERVABLE_MEM-APPD_TOTAL_RESERVED_BYTES ))
X	# warn if heap plus innodb_buffer_pool_size is greater than available RAM
X	if [ "$REQ_ZFS_ARC_MAX" -lt "0" ] ; then
X		echo "\
X$NAME: Warning!  Controller Heap + innodb_buffer_pool_size
X+ innodb_additional_mem_pool_size, ($APPD_TOTAL_RESERVED_BYTES bytes), greater
Xthan reservable system RAM, ($TOTAL_RESERVABLE_MEM bytes)."
X	else
X		if zpool list >/dev/null 2>&1 ; then 
X			ZFS_ARC_MAX=`cat /sys/module/zfs/parameters/zfs_arc_max`
X			if ([ "$ZFS_ARC_MAX" -eq "0" ] || [ "$ZFS_ARC_MAX" -gt "$REQ_ZFS_ARC_MAX" ]) ; then
X				echo $REQ_ZFS_ARC_MAX > /sys/module/zfs/parameters/zfs_arc_max
X			fi
X		fi
X	fi
X	
X
X	# If huge pages are supported and enabled.
X	if [ -n "$HUGE_PAGE_SIZE_BYTES" ] && [ "$ENABLE_HUGE_PAGES" == "true" ]
X		then
X		local SHMMAX_MAX
X		local SHMALL_MAX
X		if [[ `uname -m` == "x86_64" ]]
X			then
X			SHMMAX_MAX=`echo "2^64 - 16777217" | bc`
X		else
X			SHMMAX_MAX=`echo "2^32 - 16777217" | bc`
X		fi
X		SHMALL_MAX=$SHMMAX_MAX
X		
X	  	# Explicitly allocate and enable huge pages for the controller's
X		# java and mysql processes
X		
X		echo $(($(cat /proc/sys/vm/nr_hugepages)+APPD_HUGE_PAGES)) > /proc/sys/vm/nr_hugepages
X
X		# Allow the AppDynamics user to access the huge pages we're allocating.
X		if ! id -G $RUNUSER | grep -wq `cat /proc/sys/vm/hugetlb_shm_group`
X			then
X			echo $(id -g $RUNUSER) > /proc/sys/vm/hugetlb_shm_group
X		fi
X		
X		#check/set shmmax
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMMAX=APPD_HUGE_PAGES*HUGE_PAGE_SIZE_BYTES))
X		local PROC_SHMMAX=$(cat /proc/sys/kernel/shmmax)
X		[[ $(echo "$PROC_SHMMAX < $SHMMAX_MAX"|bc) == "1" ]] \
X			&& echo "shmmax = $PROC_SHMMAX+$APPD_SHMMAX; \
X			if (shmmax > $SHMMAX_MAX) shmmax=$SHMMAX_MAX; print shmmax;"\
X				| bc > /proc/sys/kernel/shmmax
X
X		#check/set shmmall
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMALL=APPD_SHMMAX/PAGE_SIZE_BYTES))
X		local PROC_SHMALL=$(cat /proc/sys/kernel/shmall)
X		[[ $(echo "$PROC_SHMALL < $SHMALL_MAX"|bc) == "1" ]] \
X			&& echo "shmall = $PROC_SHMALL+$APPD_SHMALL; \
X			if(shmall > $SHMALL_MAX) shmall=$SHMALL_MAX; print shmall;" \
X				| bc > /proc/sys/kernel/shmall
X	
X		# check/set unlimited memlock limit for $RUNUSER
X		if [[ $RUNUSER == "root" ]]
X			then
X			ulimit -l unlimited
X		else
X			if [[ $(su -s /bin/bash -c "ulimit -l" $RUNUSER) != "unlimited" ]]
X				then
X				echo "$RUNUSER  soft  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				echo "$RUNUSER  hard  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X			fi
X		fi
X		
X		# check/tweak db.cnf
X		if ! cat $DB_CNF | grep -Eq "^\s*large-pages"
X			then
X			runuser ex -s $APPD_ROOT/db/db.cnf <<- MYSQL_LARGE_PAGES
X				/\[mysqld\]/
X				+
X				i
X				large-pages
X				.
X				wq
X			MYSQL_LARGE_PAGES
X		fi
X		
X		# check/tweak domain.xml
X
X		if ! echo "$JVM_OPTIONS" | grep -q "\-XX:+UseLargePages"
X			then
X			runuser ex -s $DOMAIN_XML <<- JAVA_LARGE_PAGES
X				/<config name="server-config">/
X				/java-config/
X				+
X				i
X				<jvm-options>-XX:+UseLargePages</jvm-options>
X				<jvm-options>-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES</jvm-options>
X				.
X				wq
X			JAVA_LARGE_PAGES
X		elif [[ `echo "$JVM_OPTIONS" \
X			| awk '/-XX:LargePageSizeInBytes/{
X			gsub(/<\/?jvm-options>(-XX:LargePageSizeInBytes=)?/,"");
X				if(sub(/[k,K]$/,"")==1){ 
X					BYTES=$0*1024 
X				}
X				else if(sub(/[m,M]$/,"")==1){ 
X					BYTES=$0*1048576 
X				}
X				else if(sub(/[g,G]$/,"")==1){ 
X					BYTES=$0*1073741824 
X				} else { 
X					gsub(/[^0-9]/,"") 
X					BYTES=$0 
X				} 
X				print BYTES; 
X				exit;
X			}'` != "$HUGE_PAGE_SIZE_BYTES" ]]
X			then
X				runuser ex -s $DOMAIN_XML <<- ADJUST_LARGE_PAGE_SIZE
X					%s/>[\t ]*-XX:LargePageSizeInBytes=.*</>-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES</
X					wq
X				ADJUST_LARGE_PAGE_SIZE
X		fi
X		
X		# check / tweak events service settings
X		if ! ( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| grep -q "\-XX:+UseLargePages" ; then
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- EVENTS_SERVICE_LARGE_PAGES
X				a
X				-XX:+UseLargePages 
X				-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES
X				.
X				wq
X			EVENTS_SERVICE_LARGE_PAGES
X		# simplify the awk-fu below...
X		elif [[ `( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| awk -F= '/^[\t ]*-XX:LargePageSizeInBytes=/{
X				if(sub(/[k,K]$/,"",$2)==1){ 
X					BYTES=$2*1024 
X				}
X				else if(sub(/[m,M]$/,"",$2)==1){ 
X					BYTES=$2*1048576 
X				}
X				else if(sub(/[g,G]$/,"",$2)==1){ 
X					BYTES=$2*1073741824 
X				} else { 
X					gsub(/[^0-9]/,"",$2) 
X					BYTES=$2
X				} 
X				print BYTES; 
X				exit;
X			}'` != "$HUGE_PAGE_SIZE_BYTES" ]] ; then
X			#update large page size
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- ADJUST_EVENT_SERVICE_LARGE_PAGE_SIZE
X				%s/-XX:LargePageSizeInBytes=[1-9][0-9]*[k,K,m,M,g,G]\?/-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES/g
X				wq
X			ADJUST_EVENT_SERVICE_LARGE_PAGE_SIZE
X		fi
X	else
X		# disable controller MySQL and Java huge page support, if it was previously enabled
X		# remove "large-pages" from db.cnf
X		if cat $DB_CNF | grep -Eq "^\s*large-pages"
X			then
X			runuser ex -s $APPD_ROOT/db/db.cnf <<- DELETE_MYSQL_LARGE_PAGES
X				/^[\t ]*\[mysqld\][\t ]*$/
X				/^[\t ]*large-pages[\t ]*$/
X				d
X				wq
X			DELETE_MYSQL_LARGE_PAGES
X		fi
X
X		# check/tweak domain.xml
X		if echo "$JVM_OPTIONS" | grep -q "\-XX:+UseLargePages"
X			then
X			runuser ex -s $DOMAIN_XML <<- DELETE_JAVA_LARGE_PAGES
X				%s,[\t ]*<jvm-options>[\t ]*-XX:+UseLargePages[\t ]*</jvm-options>[\t ]*\n*,,g
X				%s,[\t ]*<jvm-options>[\t ]*-XX:LargePageSizeInBytes=.*</jvm-options>[\t ]*\n*,,g
X				wq
X			DELETE_JAVA_LARGE_PAGES
X		fi
X		
X		# remove events service large pages config from controller.sh
X		if ( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			 | grep -q "^[\t ]*\-XX:+UseLargePages[\t ]*" ; then
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- DELETE_EVENTS_SERVICE_LARGE_PAGES
X				%s/^[\t ]*-XX:+UseLargePages[\t ]*\n//g
X				%s/^[\t ]*-XX:LargePageSizeInBytes=.*\n//g
X				wq
X			DELETE_EVENTS_SERVICE_LARGE_PAGES
X		fi
X	fi
X}
X
Xfunction unreserve_memory(){
X	# If huge pages are supported and enabled.
X	if [ -n "$HUGE_PAGE_SIZE_BYTES" ] && [ "$ENABLE_HUGE_PAGES" == "true" ]
X		then
X		calculate_memory
X		local SHMMAX_MAX
X		local SHMALL_MAX
X		if [[ `uname -m` == "x86_64" ]]
X			then
X			SHMMAX_MAX=`echo "2^64 - 16777217" | bc`
X		else
X			SHMMAX_MAX=`echo "2^32 - 16777217" | bc`
X		fi
X		SHMALL_MAX=$SHMMAX_MAX
X		
X	  	# Explicitly allocate and enable huge pages for the controller's
X		# java and mysql processes
X		
X		echo $(($(cat /proc/sys/vm/nr_hugepages)-APPD_HUGE_PAGES)) > /proc/sys/vm/nr_hugepages
X		
X		#check/set shmmax
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMMAX=APPD_HUGE_PAGES*HUGE_PAGE_SIZE_BYTES))
X		local PROC_SHMMAX=$(cat /proc/sys/kernel/shmmax)
X		[[ $(echo "$PROC_SHMMAX < $SHMMAX_MAX"|bc) == "1" ]] \
X			&& echo "shmmax = $PROC_SHMMAX-$APPD_SHMMAX; \
X			if (shmmax > $SHMMAX_MAX) shmmax=$SHMMAX_MAX; print shmmax;"\
X				| bc > /proc/sys/kernel/shmmax
X
X		#check/set shmmall
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMALL=APPD_SHMMAX/PAGE_SIZE_BYTES))
X		local PROC_SHMALL=$(cat /proc/sys/kernel/shmall)
X		[[ $(echo "$PROC_SHMALL < $SHMALL_MAX"|bc) == "1" ]] \
X			&& echo "shmall = $PROC_SHMALL-$APPD_SHMALL; \
X			if(shmall > $SHMALL_MAX) shmall=$SHMALL_MAX; print shmall;" \
X				| bc > /proc/sys/kernel/shmall
X	fi
X}
X
Xcase "$1" in  
Xstart)  
X	require_root
X	# conditionally run reserve_memory
X	# if no lockfile or host crash (stale lockfile precedes last startup): reserve memory
X	# mysql crashed or shut down outside of intit: stale lockfile that is younger than last boot: noop
X	# mysql already running: noop
X	if ! db_running ; then
X		set_open_fd_limits
X		if ! [ -f $lockfile ] || host_crash ; then
X			reserve_memory
X		fi
X		runuser $APPD_BIN/controller.sh start-db
X	fi
X	rm -f $lockfile	
X	touch $lockfile	
X;;  
X  
Xstop)
X	require_root
X	service appdcontroller stop
X	# The default controller shutdown timeout is 45 minutes 
X	# That is a long time to be stuck with a hung appserver on the way down.
X	# Thankfully, we can set an environment variable to override that:
X	export AD_SHUTDOWN_TIMEOUT_IN_MIN=10
X	# call separately because if _stopControllerAppServer () can "exit 1"
X	# which will leave the database still running
X	runuser $APPD_BIN/controller.sh stop-db
X	unreserve_memory
X	rm -f $lockfile
X;;  
X
Xrestart)  
X	$0 stop  
X	$0 start  
X;;  
X  
Xstatus)  
X	if db_running ; then
Xcontrollerversion=`echo "select value from global_configuration_cluster where name='schema.version'" | runuser mysqlclient $APPD_ROOT | tail -1`
X	if [ ! -z $controllerversion ] ; then
X		echo version: $controllerversion
X	fi
X		echo -n "db running as $RUNUSER - "
X		if active ; then
X			echo "active"
X		else
X			echo "passive"
X			if replication_disabled ; then
X				echo replication disabled
X			fi
X		fi
X		case `echo "select value from global_configuration_local where name='ha.controller.type'" | runuser mysqlclient $APPD_ROOT | tail -1` in
X		primary) 
X			echo primary
X			;;
X		secondary)
X			echo secondary
X			;;
X		notapplicable)
X			echo HA not installed
X			;;
X		*)
X			echo unknown HA type
X			;;
X		esac
X		
X		echo "SHOW SLAVE STATUS\G" | \
X			runuser mysqlclient $APPD_ROOT | awk \
X			'/Slave_IO_State/ {print}
X			/Seconds_Behind_Master/ {print} 
X			/Master_Server_Id/ {print}
X			/Master_Host/ {print}'
X	else
X		echo "db not running"
X	fi
X;;
X
X*)  
X        echo "Usage: $0 {start|stop|restart|status}"  
X        exit 1  
Xesac
Xexit 0 
END-of-appdcontroller-db.sh
echo x - appdcontroller.sh
sed 's/^X//' >appdcontroller.sh << 'END-of-appdcontroller.sh'
X#!/bin/bash
X### BEGIN INIT INFO
X# Provides:          appdcontroller
X# Required-Start:    $remote_fs $syslog appdcontroller-db
X# Required-Stop:     $remote_fs $syslog appdcontroller-db
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Short-Description: AppDynamics Controller
X# Description:       This script starts and stops the AppDynamics Controller
X#                    Database, appserver, and HA components.
X### END INIT INFO
X#
X# $Id: appdcontroller.sh 2.15 2016-05-25 18:27:40 rob.navarro $
X# 
X# HA Aware Init file for AppDynamics Controller 
X# 
X# chkconfig: 2345 60 25 
X# description: Controller for AppDynamics
X#
X# assumes that the appdynamics controller and database run as the user 
X# specified in the db.cnf file
X#
X# edit this manually if it hasn't been automatically set by the install-init.sh
X# script
X#
X
X# Setting PATH to just a few trusted directories is an **important security** requirement
XPATH=/bin:/usr/bin:/sbin:/usr/sbin
X
XNAME=$(basename $(readlink -e $0))
X
X
XAPPD_ROOT=/opt/AppDynamics/Controller
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
XRUNUSER=root
X
XOPEN_FD_LIMIT=65536
X
XAPPD_BIN="$APPD_ROOT/bin"
Xlockfile=/var/lock/subsys/$NAME
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
XASSASSIN=$APPD_ROOT/HA/appd_assassin.pid
XWATCHDOG_ENABLE="$APPD_ROOT/HA/WATCHDOG_ENABLE"
XWATCHDOG_STATUS=$APPD_ROOT/logs/watchdog.status
XAPPSERVER_DISABLE="$APPD_ROOT/HA/APPSERVER_DISABLE"
X
X########## START of embedded hafunctions.sh ##########
X#!/bin/bash
X#
X# $Id: hafunctions.sh 1.3 2016-05-17 22:48:38 rob.navarro $
X#
X# hafunctions.sh
X# contains common code used by the HA toolkit
X# 
X###############################################################################
X#
X# IMPORTANT - 	add function names to "export -f" list at bottom of this file
X#              	that should be callable by sub-shells. Any function not so added
X#	 	will not be visible to any sub-shells e.g. $(...), pipelines etc.
X#
X###############################################################################
X
Xfunction err {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "ERROR: $PROGNAME: $*" 1>&2
X        exit 1
X}
X
Xfunction warn {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "WARNING: $PROGNAME: $*" 1>&2
X}
X
X# Helper function to entirely encapsulate variable substitution logic applied to Init
X# scripts during installation.
X# Uses global variables: APPD_ROOT RUNUSER MA_install_dir
X# Call as:
X#   convert_init_script $infile > $outfile
Xfunction convert_init_script {
X        (( $# == 1 )) || err "convert_init_script: needs 1 arg"
X        local infile=$1
X
X        [[ -f $infile ]] || err "convert_init_script: unable to read '$infile'"
X        sed < $infile \
X                -e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X                -e "/^RUNUSER=/s,=.*,=$RUNUSER," \
X                -e "/^MACHINE_AGENT_HOME=/s,=.*,=$MA_install_dir,"
X}
X
X#
X# Collection of routines to deal with MySQL root password
X#
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa1 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa1 <data>
Xfunction obf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(tr '\!-~' 'P-~\!-O' < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 obfuscation"
X	obf=$(base64 -w 0 < <(echo -n $step1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa1 <data>
Xfunction deobf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(base64 -d -w 0 < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 deobfuscation"
X	clear=$(tr '\!-~' 'P-~\!-O' < <(echo -n $step1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa2 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa2 <data>
Xfunction obf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	obf=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa2 <data>
Xfunction deobf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	clear=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# overall wrapper function for obfuscation 
X# Call as
X#  obfuscate <obf type> <data>
X# or
X#  obfuscate <data>
Xfunction obfuscate {
X	(( $# == 1 || $# == 2 )) || err "Usage: ${FUNCNAME[0]} [<obf type>] <data>"
X
X	local thisfn=${FUNCNAME[0]} data otype
X	if (( $# == 2 )) ; then
X		otype=$1
X		data=$2
X	else
X		otype=''
X		data=$1
X	fi
X	case $otype in
X		ofa1 | '' )	obf_ofa1 $data ;;	# default case
X		ofa2)		obf_ofa2 $data ;;
X		*)		err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X# overall wrapper for various de-obfuscator functions
X# Call as:
X#  deobfuscate <otype> <obf_data>
Xfunction deobfuscate {
X	(( $# == 2 )) || err "Usage: ${FUNCNAME[0]} <obf type> <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} otype=$1 data=$2
X	case $otype in
X		ofa1)	deobf_ofa1 "$data" ;;
X		ofa2)	deobf_ofa2 "$data" ;;
X		*)	err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X###
X
X# with help from:
X# http://stackoverflow.com/questions/1923435/how-do-i-echo-stars-when-reading-password-with-read
Xfunction getpw { 
X        (( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <variable name>"
X        local pwch inpw1 inpw2=' ' prompt; 
X        
X        ref=$1 
X	while [[ "$inpw1" != "$inpw2" ]] ; do
X		prompt="Enter MySQL root password: "
X		inpw1=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw1+=$pwch 
X			fi 
X		done 
X
X		prompt="re-enter same password: "
X		inpw2=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw2+=$pwch 
X			fi 
X		done 
X	
X		[[ "$inpw1" == "$inpw2" ]] || echo "passwords unequal. Retry..." 1>&2
X	done
X
X	# indirect assignment (without local -n) needs eval. 
X	# This only works with global variables :-( Please use weird variable names to
X	# avoid namespace conflicts...
X        eval "${ref}=\$inpw1"            # assign passwd to parameter variable
X}
X
X# helper function to allow separate setting of passwd from command line.
X# Use this to persist an obfuscated version of the MySQL passwd to disk.
X# Call as:
X#  . hafunctions.sh
X#  save_mysql_passwd $APPD_ROOT
Xfunction save_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	getpw __inpw1 || exit 1		# updates __inpw1 *ONLY* if global variable
X	obf=$(obfuscate $__inpw1) || exit 1
X	echo $obf > $rootpw_obf || err "$thisfn: failed to save obfuscated passwd to $rootpw_obf"
X	chmod 600 $rootpw_obf || warn "$thisfn: failed to make $rootpw_obf readonly"
X}
X
X# get MySQL root password in a variety of ways. Implement the concept:
X# 1. respect MYSQL_ROOT_PASSWD if present; please pass down to sub-scripts. Do NOT persist to disk.
X# 2. respect $APPD_ROOT/db/.rootpw if present
X# 3. respect $APPD_ROOT/db/.rootpw.obf if present
X# 4. otherwise get MySQL root passwd from command line, obfuscate and persist to $APPD_ROOT/db/.rootpw.obf
X#
X# Call as:
X#  $dbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xfunction get_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 clear obf otype inpw2=' '
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw="$APPD_ROOT/db/.rootpw" rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	if [[ -n "$MYSQL_ROOT_PASSWD" ]] ; then
X		echo $MYSQL_ROOT_PASSWD
X	elif [[ -s $rootpw && -r $rootpw ]] ; then 
X		echo $(<$rootpw)
X	elif [[ -s $rootpw_obf ]] ; then
X		IFS=$' ' read -r otype obf < $rootpw_obf
X		[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X		clear=$(deobfuscate $otype $obf) || exit 1
X		[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X		echo $clear
X	else
X		# if STDIN/STDOUT open & connected to a terminal - ie not run as a service, daemon or over ssh
X		if [[ -t 0 && -t 1 ]] ; then
X			save_mysql_passwd $APPD_ROOT			# but save writes directly to disk 
X			IFS=$' ' read -r otype obf < $rootpw_obf	# so need to read back in...
X			[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X			clear=$(deobfuscate $otype $obf) || exit 1
X			[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X			echo $clear
X		else				# give up with an error
X			local RUNUSER=$(awk -F= '$1=="user" { print $2  }' $APPD_ROOT/db/db.cnf)
X			[[ -n "$RUNUSER" ]] || RUNUSER=MySQL
X			err "$thisfn: unable to get MySQL root passwd. As $RUNUSER user run \"(cd HA;. hafunctions.sh;save_mysql_passwd \$(pwd)/..)\" interactively and try again."
X		fi
X	fi
X}
X
X# because there is currently no single program guaranteed to run before using the other scripts
X# we need each script to be able to check whether MySQL root passwd has been set or not.
X# LATER: This can be fixed in future with a self-extracting archive that includes install logic. 
X# Call as:
X#  check_for_mysql_passwd $APPD_ROOT || exit 1
Xfunction check_for_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	get_mysql_passwd $1 >/dev/null 
X}
X
X# make-do function that ignores junk header of controller.sh login-db output that precedes the
X# actual mysql client output and outputs the 1 chosen line requested. This became necessary
X# as folk chose to follow mysql client output with extraneous newline. 
X# Replace 'controller.sh login-db | tail -1' with 'controller.sh login-db | getsqlrow 2'
X# Will be obsolete once clean mysql client output is provided.
X#
X# Call as:
X#  SQLval=$(bin/controller.sh login-db | getsqlrow 2)
Xfunction getsqlrow {
X	(( $# == 1 )) && [[ $1 =~ ^[[:digit:]]+$ ]] || err "Usage: ${FUNCNAME[0]} <mysql client output row #>" || exit 1
X
X   	local LINE pattern='^Logging into the controller database' skiprows
X   	while read -r LINE ; do
X		if [[ $LINE =~ $pattern ]] ; then
X			for (( skiprows=1; skiprows<=$1; ++skiprows )); do 
X				IFS= read -r LINE || return
X	   		done
X	   		echo $LINE		# or preserve leading whitespace with "$LINE"
X			return
X		fi
X   	done
X}
X
X# replacement for calling 'controller.sh login-db' that is guaranteed to only output what 
X# underlying mysql client does. This makes it much easier to reliably parse.
X# Call as:
X#  VAL=$(echo "some SQL" | mysqlclient $APPD_ROOT | grep -q "active")
Xfunction mysqlclient {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <controller install directory>"
X
X	local APPD_ROOT=$1
X	[[ -n "$MYSQL_ROOT_PASSWD" ]] || MYSQL_ROOT_PASSWD=$(get_mysql_passwd $APPD_ROOT) || exit 1
X  	[[ -n "$DB_PORT" ]] || DB_PORT=$(awk -F= '$1=="port" { print $2  }' $APPD_ROOT/db/db.cnf) || exit 1
X	[[ -n "$DB_PORT" ]] || err "${FUNCNAME[0]}: unable to read MySQL port number from $APPD_ROOT/db/db.cnf"
X
X	$APPD_ROOT/db/bin/mysql -A -u root -p"${MYSQL_ROOT_PASSWD}" --port=$DB_PORT --protocol=TCP controller
X}
X
X###############################################################################
X#
X# FOOTER block
X#
X# IMPORTANT  - add function names here which should be callable by sub-shells
X#
X###############################################################################
Xexport -f err warn getpw obf_ofa1 obf_ofa2 obfuscate
Xexport -f mysqlclient get_mysql_passwd save_mysql_passwd deobfuscate deobf_ofa1 deobf_ofa2
X
X########## END of embedded hafunctions.sh ##########
X
Xif [ `id -un` == $RUNUSER ] ; then
X        function bg_runuser {
X                exec nohup $* >/dev/null 2>&1 &
X        }
X        function runuser {
X                $*
X        }
Xelse
X        function bg_runuser {
X                su -m -s /bin/bash -c "exec nohup $* >/dev/null 2>&1 &" $RUNUSER
X        }
X        function runuser {
X                su -m -s /bin/bash -c "$*" $RUNUSER
X        }
Xfi
X
X# source of SQL pulls in need for passwd, which pulls in need for runuser.
X# Hence this library inclusion needs to follow the runuser function declaration.
X### Included from get_replication_master.sh
X# include sql() helper function
X### included from sql.sh
X# ASSUMES:
X# 1. APPD_ROOT was set in the sourcing script
X# 2. APPD_ROOT/HA/hafunctions.sh is sourced in caller script (to define various functions)
X# 3. runuser function declared
Xdbuser=root
X#dbpasswd=`cat $APPD_ROOT/db/.rootpw`
Xdbpasswd=$(runuser get_mysql_passwd $APPD_ROOT) || exit 1
Xexport MYSQL_ROOT_PASSWD=$dbpasswd
Xdbport=`grep ^DB_PORT $APPD_ROOT/bin/controller.sh | cut -d = -f 2`
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XCONNECT="--protocol=TCP --user=$dbuser --password=$dbpasswd --port=$dbport"
X
X#
X# worker function for sql timer
X#
Xfunction sqltimeout {
X        if [ $sqlpid -ne 0 ] ; then
X                # TODO: rethink HA toolkit logging abstractions.
X                >&2 echo "killing sql pid $sqlpid"
X                disown $sqlpid
X                kill -9 $sqlpid
X                sqlpid=0
X                sqlkiller=0
X        fi
X}
X
Xfunction sql {
X        # TODO: rethink HA toolkit logging abstractions.
X		# echo sql $1 "$2" $3 >> $fo_log
X		local tmpfile
X		local DELFILES
X		local mypid
X        local retval
X        if [ $# -lt 3 ] ; then
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller
X        else
X                trap sqltimeout SIGALRM
X                tmpfile=/tmp/sql_result.$$
X                rm -f $tmpfile
X                DELFILES=$tmpfile
X                mypid=$$
X                (sleep $3 ; kill -SIGALRM $mypid) &
X                sqlkiller=$!
X                disown $sqlkiller
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller > "$tmpfile" &
X                sqlpid=$!
X                wait $sqlpid
X                retval=$?
X                if [ $sqlkiller -ne 0 ] ; then
X                        kill -9 $sqlkiller
X                fi
X                cat $tmpfile
X                rm -f $tmpfile
X                DELFILES=
X                return $retval
X        fi
X}
X### end include from sql.sh
X
Xget_replication_master(){
X    sql localhost "show slave status\G" 5 | awk '/Master_Host:/{print $2}'
X}
X### End of include from get_replication_master.sh
Xif [ -f $APPD_ROOT/HA/LARGE_PAGES_ENABLE ] ; then
X	ENABLE_HUGE_PAGES="true"
Xfi
X
X# enable Debian systems to work also
Xfunction service {
X	if [[ -z "$service_bin" ]] ; then
X		if [[ -f /sbin/service ]] ; then
X		        service_bin=/sbin/service
X		elif [[ -f /usr/sbin/service ]] ; then
X		        service_bin=/usr/sbin/service
X		else
X			echo service not found in /sbin or /usr/sbin - exiting
X			exit 13
X		fi
X		$service_bin $*
X	else
X		$service_bin $*
X	fi
X}
X
Xfunction require_root {
X	if [ `id -un` != "root" ] ; then
X		echo "service changes must be run as root"
X		exit 1
X	fi
X}
X
X#
X# trivial sanity check
X#
Xif runuser [ ! -f $APPD_ROOT/db/db.cnf ] ; then
X	echo appd controller not installed in $APPD_ROOT
X	exit 1
Xfi
Xif runuser [ ! -x $APPD_BIN/controller.sh ] ; then
X	echo controller disabled on this host
X	exit 1
Xfi
X
Xfunction enable_pam_limits() {
X	if [ -f /etc/pam.d/common-session ] && ! grep  -Eq "^\s*session\s+required\s+pam_limits\.so" /etc/pam.d/common-session
X		then
X		echo "session required	pam_limits.so" >> /etc/pam.d/common-session
X	elif [ -f /etc/pam.d/system-auth ] && ! grep  -Eq "^\s*session\s+required\s+pam_limits\.so" /etc/pam.d/system-auth
X		then
X		echo "session required	pam_limits.so" >> /etc/pam.d/system-auth
X	fi
X}
X
X# always make sure this gets called before any other functions that modify
X# /etc/security/limits.d/appdynamics.com, i.e. set_unlimited_memlock()
Xfunction set_open_fd_limits() {
X	if [ "$RUNUSER" == "root" ] && [[ `ulimit -S -n` -lt $OPEN_FD_LIMIT ]]
X		then
X		ulimit -n $OPEN_FD_LIMIT
X	elif [[ `su -s /bin/bash -c "ulimit -S -n" $RUNUSER` -lt "$OPEN_FD_LIMIT" ]]
X		then
X		echo "$RUNUSER  soft  nofile $OPEN_FD_LIMIT" > /etc/security/limits.d/appdynamics.conf
X		echo "$RUNUSER  hard  nofile $OPEN_FD_LIMIT" >> /etc/security/limits.d/appdynamics.conf
X		enable_pam_limits
X	fi
X}
X
Xset_unlimited_memlock() {
X	if [ "$ENABLE_HUGE_PAGES" == "true" ] ; then
X		if [[ $RUNUSER == "root" ]]
X			then
X			ulimit -l unlimited
X		else
X			if [[ $(su -s /bin/bash -c "ulimit -l" $RUNUSER) != "unlimited" ]]
X				then
X				echo "$RUNUSER  soft  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				echo "$RUNUSER  hard  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				enable_pam_limits
X			fi
X		fi
X	fi
X}
X
Xfunction watchdog_running() {
X	if runuser [ -f "$WATCHDOG" ] ; then
X		WATCHPID=`runuser cat $WATCHDOG`
X		if [ ! -z "$WATCHPID" ] ; then
X			if [ -d /proc/$WATCHPID ] ; then
X				return 0
X			fi
X		fi
X	fi
X	return 1
X}
X
XDB_CNF=/tmp/db.cnf.$$
Xfunction cleanup() {
X    rm -f $DB_CNF
X}
Xtrap cleanup EXIT
X
Xcleanup
Xrunuser cat $APPD_ROOT/db/db.cnf > $DB_CNF
X
Xfunction assassin_running() {
X	if runuser [ -f "$ASSASSIN" ] ; then
X		ASSASSINPID=`runuser cat $ASSASSIN`
X		if [ ! -z "$ASSASSINPID" ] ; then
X			if [ -d /proc/$ASSASSINPID ] ; then
X				return 0
X			fi
X		fi
X	fi
X	return 1
X}
X
Xfunction db_running() {
X	DB_PID_FILE=`cat $DB_CNF | grep "^\s*pid-file" | cut -d = -f 2`
X	DB_DATA_DIR=`cat $DB_CNF | grep "^\s*datadir" | cut -d = -f 2`
X	if [ -z "$DB_PID_FILE" ] ; then
X		DB_PID_FILE="$DB_DATA_DIR/$(hostname).pid"
X	fi
X	if [ -z "$DB_PID_FILE" ] ; then
X		return 1
X	fi
X	DB_PID=`runuser cat $DB_PID_FILE 2>/dev/null`
X	if [ -z "$DB_PID" ] ; then
X		return 1
X	fi
X	if [ -d /proc/$DB_PID ] ; then
X		return 0;
X	fi
X	return 1	
X}
X
Xfunction replication_disabled() {
X	if cat $DB_CNF | grep -q "^\s*skip-slave-start=true" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction active() {
X	if echo select value from global_configuration_local \
X		where "name='appserver.mode'" | \
X		runuser mysqlclient $APPD_ROOT | \
X		tail -1 | grep -q "active" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction controllerrunning () {
X	if pgrep -f -u $RUNUSER "$APPD_ROOT/jre/bin/java -jar ./../modules/admin-cli.jar" >/dev/null ; then
X		return 1
X	fi
X	if runuser $APPD_ROOT/appserver/glassfish/bin/asadmin list-domains | \
X		grep -q "domain1 running" ; then
X		return 0
X	else
X		return 2
X	fi
X}
X
Xfunction events_running () {
X	if ps -f -u $RUNUSER | grep "$APPD_ROOT/jre/bin/java" | grep "$APPD_ROOT/events_service" >/dev/null ; then
X		return 0
X	fi
X	return 1
X}
X
Xfunction reporting_running () {
X	if pgrep -f -u $RUNUSER "$APPD_ROOT/reporting_service/nodejs/bin/node" >/dev/null ; then
X		return 0
X	fi
X	return 1
X}
X
Xfunction machine_agent_running () {
X	if service appdynamics-machine-agent status &> /dev/null; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xcase "$1" in
Xstart)  
X	require_root
X	if runuser [ -f $APPSERVER_DISABLE ] ; then
X		echo appdcontroller disabled - incomplete replica:w
X		exit 1
X	fi
X	service appdcontroller-db start
X	set_open_fd_limits
X	set_unlimited_memlock
X	if [[ `id -u $RUNUSER` != "0" ]] && \
X		[[ `echo "cat //*[@port<1024]" | runuser xmllint --shell $DOMAIN_XML | wc -l` -gt 1 ]] ; then
X		#trying to bind java to a privilged port as an unpriviliged user
X		setcap cap_net_bind_service=+ep $APPD_ROOT/jre/bin/java
X		echo "$APPD_ROOT/jre/lib/$(uname -m | sed -e 's/x86_64/amd64/')/jli" > \
X			/etc/ld.so.conf.d/appdynamics.conf
X		ldconfig            
X	fi
X	if active ; then
X		bg_runuser $APPD_BIN/controller.sh start-appserver
X		if replication_disabled ; then
X			if assassin_running ; then
X				echo assassin already running
X			else
X				echo starting assassin 
X				bg_runuser $APPD_ROOT/HA/assassin.sh
X			fi
X		fi
X		if runuser [ -d $APPD_ROOT/events_service ] ; then
X			bg_runuser $APPD_BIN/controller.sh start-events-service
X		fi
X		if runuser [ -d $APPD_ROOT/reporting_service ] ; then
X			bg_runuser $APPD_BIN/controller.sh start-reporting-service
X		fi
X	else
X		if replication_disabled ; then
X			echo passive node - appd replication disabled
X			exit 1
X		fi
X		echo skipping appserver start - HA passive
X		if runuser [ -f $WATCHDOG_ENABLE ] ; then
X			if watchdog_running ; then
X				echo appd watchdog already running 
X			else
X				echo starting appd watchdog
X				bg_runuser $APPD_ROOT/HA/watchdog.sh
X			fi
X		else
X			echo watchdog disabled
X		fi
X	fi
X	rm -f $lockfile	
X	touch $lockfile	
X;;  
X  
Xstop)
X	require_root
X	if watchdog_running ; then
X		kill -9 $WATCHPID && ( echo appd watchdog killed; \
X		runuser "echo `date` appd watchdog killed >> $APPD_ROOT/logs/watchdog.log" )
X	fi
X	runuser rm -f $WATCHDOG
X	if assassin_running ; then
X		kill -9 $ASSASSINPID && ( echo appd assassin killed; \
X		runuser "echo `date` appd assassin killed >> $APPD_ROOT/logs/assassin.log" )		
X	fi
X	runuser rm -f $ASSASSIN
X	# TODO: stop automatically starting and stopping the local events service since
X	#   an HA controller pair should be talking to a separate events service cluster.
X	if runuser [ -d $APPD_ROOT/events_service ] ; then
X		runuser $APPD_BIN/controller.sh stop-events-service
X	fi
X	if runuser [ -d $APPD_ROOT/reporting_service ] ; then
X		runuser $APPD_BIN/controller.sh stop-reporting-service
X	fi
X	# The default controller shutdown timeout is 45 minutes 
X	# That is a long time to be stuck with a hung appserver on the way down.
X	# Thankfully, we can set an environment variable to override that:
X	export AD_SHUTDOWN_TIMEOUT_IN_MIN=10
X    	runuser $APPD_BIN/controller.sh stop-appserver
X	controllerrunning
X	if [ $? -lt 2 ] ; then
X		echo "forcibly killing appserver"
X		pkill -9 -f "$APPD_ROOT/jre/bin/java -cp $APPD_ROOT/lib/tools.jar"
X		echo "truncate ejb__timer__tbl;" | runuser $APPD_BIN/controller.sh login-db
X	fi
X
X	if [ -e $APPD_ROOT/logs/server.log.lck ] ; then
X		runuser rm -f $APPD_ROOT/logs/server.log.lck
X	fi
X	rm -f $lockfile
X;;
X
Xrestart)  
X	$0 stop  
X	$0 start  
X;;  
X  
Xstatus)  
X	retcode=0
X	service appdcontroller-db status
X	if watchdog_running ; then
X		echo watchdog running
X		if [ -f $WATCHDOG_STATUS ] ; then
X			cat $WATCHDOG_STATUS
X		fi
X	else
X		echo watchdog not running
X	fi
X	if assassin_running ; then
X		echo assassin running
X	else
X		echo assassin not running
X	fi
X	controllerrunning
X	case $? in
X	0)
X		echo "controller running"
X		;;
X	1)
X		echo "controller started - not up"
X		retcode=1
X		;;
X	*)
X		echo "controller not running"
X		retcode=1
X		;;
X	esac
X	events_running
X	case $? in
X	0)
X		echo "events service running"
X		;;
X	*)
X		echo "events service not running"
X		;;
X	esac
X	reporting_running
X	case $? in
X	0)
X		echo "reporting service running"
X		;;
X	*)
X		echo "reporting service not running"
X		;;
X	esac
X	machine_agent_running
X	case $? in
X	0)
X		echo "machine-agent service running"
X		;;
X	*)
X		echo "machine-agent service not running"
X		;;
X	esac
X	exit $retcode
X;;
X
X*)  
X        echo "Usage: $0 {start|stop|restart|status}"  
X        exit 1  
Xesac
Xexit 0 
END-of-appdcontroller.sh

# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	README
#	assassin.sh
#	failover.sh
#	watchdog.sh
#	watchdog.settings.template
#	replicate.sh
#	install-init.sh
#	uninstall-init.sh
#	appdservice.c
#	appdservice-pbrun.sh
#	appdservice-root.sh
#	appdservice-xuser.sh
#	appdynamics-machine-agent.old.sh
#	appdynamics-machine-agent.old.sysconfig
#	appdynamics-machine-agent.sh
#	appdynamics-machine-agent.sysconfig
#	hafunctions.sh
#	mysqlclient.sh
#	RUNBOOK
#
echo x - README
sed 's/^X//' >README << 'END-of-README'
XContents:
X
X	README: this file
X	RUNBOOK:  a list of state descriptions, validations, and remedial actions
X
X
X	replicate.sh:  the all-singing, all-dancing HA (re)activator
X	this installs and sets up the HA function for a controller pair.
X
X	appdcontroller.sh: a file intended to be placed into /etc/init.d to control
X	the controller, watchdog, and assassin
X
X	appdcontroller-db.sh: a file intended to be placed into /etc/init.d to control
X	the mysql database
X
X	assassin.sh:  a script run on a failed-over primary to kill the old primary
X
X	failover.sh:  a script run on a secondary to become the new primary
X
X	install-init.sh:  an installer for the appdcontroller.sh
X
X	uninstall-init.sh:  an uninstaller for the appdcontroller.sh
X
X	watchdog.sh:  run on a secondary to watch the primary and maybe failover
X
X	watchdog.settings.template:  copy this to watchdog.settings to override defaults
X
X	appdservice-root.sh:  a null privilege escalation wrapper
X
X	appdservice-pbrun.sh:  a privilege escalation wrapper around pbrun
X
X	appdservice.c:  a privilege escalation c program
X	
XInstallation notes:
XThis software is intended to connect the appdynamics controller into linux's
Xservice machinery.  This optionally includes a watchdog process running on the
Xsecondary HA node that will initiate a failover if a failure is detected in
Xthe primary controller or database.
X
XPermissions: 
X	If the controller is to be run as a non-root user, part of the 
Xinstallation cannot be directly automated, as it involves installing of a 
Xsystem service into /etc/init.d and ancillary directories using install-init.sh
X
XPrerequisites:
X--------------
X	1) Ssh must be installed in such a way that the user the controller is to 
Xbe run as has symmetrical passwordless ssh access.  This is done by generating 
Xa key pair on each node, and placing the other's public key into the appropriate
Xauthorized_keys file.  in detail, assuming user appduser, node1 and node2
X
X	on node1:
X
X	su - appduser
X	mkdir -p .ssh
X	ssh-keygen -t rsa -N "" -f .ssh/id_rsa
X	scp .ssh/id_rsa.pub node2:/tmp
X
X	on node2:
X
X	su - appduser
X	mkdir -p .ssh
X	ssh-keygen -t rsa -N "" -f .ssh/id_rsa
X	cat /tmp/id_rsa.pub >> .ssh/authorized_keys
X	scp .ssh/id_rsa.pub node1:/tmp
X
X	on node1:
X	cat /tmp/id_rsa.pub >> ~/.ssh/authorized_keys
X
XAll of the above commands may not be needed, and some of them may prompt for a
Xpassword.
X
X	2) reliable symmetrical reverse host lookup must be configured.  the best
Xway is to place the host names into each /etc/hosts file.   reverse DNS adds 
Xan additional point of failure.  
X		a) /etc/nsswitch.conf should have files placed before dns. example:
X			hosts:      files dns
X		b) /etc/hosts:
X			192.168.144.128 host1
X			192.168.144.137 host2
X
X	3) each machine must have the root and data directory writable by the 
Xappropriate appdynamics user:
X
X	ls -lad /opt/AppDynamics/Controller
Xdrwxr-xr-x. 18 appduser users    4096 Jan 26 18:18 /opt/AppDynamics/Controller
X
X	4) the primary controller should be installed as a standalone controller;
Xthe secondary should not be installed at all.
X
XInstallation:
X-------------
XOn the primary, unpack the shar file using bash into a directory HA under the 
Xcontroller root install subdirectory.
X
X	cd /opt/AppDynamics/Controller
X	mkdir -p HA
X	chmod +w *
X	bash HA.shar
X
XActivation:
X-----------
XThe key script to replicate the primary database to the secondary, make all the
Xappropriate state changes, and activate the HA pair is the replicate.sh script.
Xit is run on an active controller.  Attempts to run it on a passive controller 
Xwill be rejected.  it has a few specialized options, but it has reasonable
Xdefaults and is extracts a lot of configuration information from the existing
Xinstallation.  the most simple usage is to activate a HA pair immediately.
Xrun the following as the same user as appdynamics is running as.
Xsince the controller is taken down, the command will prompt for a confirmation message.
X
X	./replicate.sh -s node2 -f -w -e proxy
X
Xwhen it has completed, the HA pair will be running and replicating.
XIf running as non-root, the command asks that some commands manually be run as
Xroot to complete the installation.
X
XIncremental Activation:
X-----------------------
XRuns of the replicate script without the -f option will perform an imperfect 
Xcopy of the primary controller to the secondary without taking the primary down.
XThis can be used to minimize the downtime necessary to do the initial 
Xinstallation.  if the data volume to replicate is large, several runs without
Xthe -f option would approach a perfect copy over a period of days.  the final
Xactivation with -f during a maintenance window would only copy those data filesi
Xthat differ from the last copy.
X
XPrivilege Escalation:
X---------------------
Xthe install-init.sh script is used to install the init scripts, and to set
Xup a controlled privilege escalation.  this can take the form of sudo settings,
Xor one of 3 flavors of /sbin/appdservice. run install-init.sh for usage.
X
XService Control:
X----------------
XAfter activation, the controller service and HA facility can be controlled 
Xusing the linux service command.  these options must be executed as root.
XThe default installation will automatically shut down the controller when
Xthe system is halted, and automatically start it at boot time.
X
X	service appdcontroller start
X	service appdcontroller stop
X
Xan additional service, appdcontroller-db, is used to manage the database.
Xa sensible dependency between the two services is implemented
X
XStatus:
X-------
XOnce installed as a service, the linux service utility can be run on either
Xnode to report the current state of the replication, background processes, and
Xthe controller itself.
X
X	service appdcontroller status
X
XWatchdog:
X---------
XIf enabled, this background process running on the secondary will monitor the
Xprimary controller and database, and if it detects a failure, will initiate a
Xfailover automatically.   The failure mode timings are defined in watchdog.sh.
XThe watchdog is only enabled if the file <controller root>/HA/WATCHDOG_ENABLE
Xexists. Removing the file causes the watchdog to exit.
X
Xto enable the watchdog, as root:
X	touch <controller root>/HA/WATCHDOG_ENABLE
X	chmod 777 <controller root>/HA/WATCHDOG_ENABLE
X	service appdcontroller start
X
Xrunning the replicate.sh script with the -w option at final activation will 
Xcreate the watchdog control file automatically.
X
XAssassin:
X---------
XAfter a failover, it is possible that the old primary may come online.  If this
Xoccurs, the load balancer may send load to the old primary.  To prevent this,
Xthe new primary continually polls the old primary and if it becomes accessible,
Xkills it and inhibits it from starting again.
X
XFailover:
X---------
XA manual failover can be triggered by running failover.sh on the secondary.
XThis will kill the watchdog and activate the database.  it will also try to
Xassassinate the old primary.
XThis only happens if replication is broken. if replication is good, we just
Xdeactivate the other appserver and activation this one, while leaving the db
Xup.  this case also does not fire up the assassin.
X
XLogging:
X--------
Xthe logs directory contains several status and progress logs of the various components.
X
XRemote controller monitoring
X----------------------------
XIf desired it is possible to have the controller's internal Java app agent report to 
Xanother controller. This is most often useful if two or more controllers have been
Xdeployed on-premises. Having them both report their health to a controller monitor
Xsimlifies the monitoring of them all as common health rules and notification policies are
Xmore easily re-used.
X
XAt least four pieces of information are needed to configure remote controller 
Xmonitoring:
X	- controller monitor's hostname
X	- controller monitor's port
X	- account name within controller monitor
X	- controller monitor's access key for that account
X	- [optional] application name to report under
X
XThe controller monitor's account names and access keys can be determined with:
X	cd <controller install dir>
X	echo "select access_key,name,id from account\G"| bin/controller.sh login-db
X
XYou can send a controller's app agent output to another controller with hostname
X"cmonitor", access_key "ac-ce-ss-key", account name "customer1", application name 
X'Prod HA pair' with:
X	./replicate.sh -s <secondary> -m url=http://cmonitor:8090,access_key="ac-ce-ss-key",account_name=customer1,app_name='Prod HA pair' -f
X
XMachine Agent
X-------------
XHaving a machine agent on both primary and secondary servers is a pre-requisite step 
Xto simple monitoring and warning of critical health issues affecting the stability
Xof the HA controller pair. Getting to this state involves:
X	1. downloading and installing the machine agent on both primary and
X	   secondary servers from download.appdynamics.com. For compatibility see 
X	   docs.appdynamics.com for your version of the controller.
X	   Ensure that the machine agent install directory is the *same* for both
X	   primary and secondary servers.
X	2. Ensure that the same version of the HA Toolkit is available on both
X	   primary and secondary servers. Use scp or replicate.sh -s <other> 
X	3. As root (re)run HA Toolkit install on both primary and secondary servers
X	   including '-a <agent install dir>' parameter. For example:
X		sudo ./install-init.sh -s -a /opt/appdyn/machine-agent/4.1.5.1
X	4. As regular AppD user (re)run replicate.sh .. -f to shutdown controller and
X	   configure all remaining files with an extra parameter referring to machine
X	   agent install directory. For example:
X	   	replicate.sh -s <secondary> -e https://proxy -a /opt/appdyn/machine-agent/3.9.0.0 -t 0 -z -f 
X
XIf a remote controller monitor has been configured, include that '-m' option in the 
Xreplicate.sh command to ensure the machine agents report there also. For example:
X		./replicate.sh -s <secondary> -m url=http://cmonitor:8090,access_key="ac-ce-ss-key",account_name=customer1,app_name='Prod HA pair' -a /opt/appdyn/machine-agent/3.9.0.0 -f
X
XBest Practices:
X---------------
XIf possible, a dedicated network connection should be provisioned between the
XHA pair.  this set of interfaces should be the ones placed into the /etc/hosts
Xfiles, and used as the argument for the -s option to the replicate.sh script.
X
XBackups are best done by stopping the appdcontroller service on the secondary
Xand performing a file-level copy of the appdynamics directories.  these can
Xbe incremental or complete, depending on the reliability of your solution.
Xwhen the backup is done, simply start the service; replication will catch up
Xand guarantee the integrity of your data.
X
XA load balancer can probe http://<controller>:<port>/rest/serverstatus
Xto determine which of the two controllers is active. the active node will
Xreturn a HTTP 200.
X
Xshould it be necessary to have a hook in the failover process, for example to update 
Xa dynamics DNS service or to notify a load balancer or proxy, the failover.sh script 
Xis the place to add code.
X
XVersion:
X--------
X$Id: README 1.9 2015-12-23 00:36:28 cmayer Exp $
X
END-of-README
echo x - assassin.sh
sed 's/^X//' >assassin.sh << 'END-of-assassin.sh'
X#!/bin/bash
X#
X# $Id: assassin.sh 2.10 2016-05-25 18:29:24 rob.navarro $
X#
X# assassin.sh
X# run on the active node after a failover, 
X# this shoots down any secondary controller to prevent two actives 
X# from showing up at the load balancer - we won't have any data integrity \
X# problems, since replication is off
X# 
X
X# comment out to print logging messages to STDOUT
Xsilence=">/dev/null"
X
X#
X# this may need editing to conform with your controller install
X#
Xdbuser=root
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd -P)
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X	#shldignore		# stop Makefile trying to embed the next source file
X        . $FUNCLIB
Xelse
X        echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X        exit 1
Xfi
X
Xdbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xdbport=`grep ^DB_PORT $APPD_ROOT/bin/controller.sh | cut -d = -f 2`
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=$dbuser --password=$dbpasswd --port=$dbport"
XASSASSIN=$APPD_ROOT/HA/appd_assassin.pid
X
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xas_log=$APPD_ROOT/logs/assassin.log
X
Xif [ -f /sbin/service ] ; then
X    service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X    service_bin=/usr/sbin/service
Xelse
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 1
Xfi
X
X# execute remote service operation
X# args:  flags machine service verb
Xfunction remservice {
X	if [ `id -u` == 0 ] ; then
X		ssh $1 $2 $service_bin $3 $4
X	else
X		if ssh $2 [ -x /sbin/appdservice ] ; then
X			ssh $1 $2 /sbin/appdservice $3 $4
X		else
X			ssh $1 $2 sudo -n $service_bin $3 $4
X		fi
X	fi
X}
X
Xfunction sql {
X	echo "$2 | $MYSQL --host=$1 $CONNECT controller" | $PWBLOCK >> $as_log
X	echo "$2" | $MYSQL --host=$1 $CONNECT controller 2>> $as_log | tee -a $as_log
X}
X
Xecho "  -- assassin log" `date` >> $as_log
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X	echo db configuration $APPD_ROOT/db is not a directory | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ ! -x "$MYSQL" ] ; then
X	echo controller root $MYSQL is not executable | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# we must be the active node
X#
Xmode=`sql localhost \
X "select * from global_configuration_local where name = 'appserver.mode'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$mode" == "passive" ] ; then
X	echo "this script must be run on the active node" | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# if we are the 'marked primary', the assassin is not needed any more
X#
Xtype=`sql localhost \
X "select * from global_configuration_local where name = 'ha.controller.type'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$type" == "primary" ] ; then
X	echo "assassin unneeded" | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# replication must be not be enabled.  there are several markers for this:  
X# skip-slave start is set in out db.cnf
X# the slave is not running
Xif ! grep -q "^skip-slave-start=true" $DBCNF ; then
X	echo slave not disabled | tee -a $as_log $silence
X	exit 1
Xfi
Xprimary=unset
Xeval `sql localhost "show slave status\G" | awk '
X	BEGIN { OFS="" }
X    /Slave_IO_Running:/ {print "slave_io=",$2}
X    /Slave_SQL_Running:/ {print "slave_sql=",$2}
X    /Master_Host:/ {print "primary=",$2}
X'`
Xif [ "$slave_sql" != "No" ] ; then
X	echo slave SQL running | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ "$slave_io" != "No" ] ; then
X	echo slave IO running | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ "$primary" == "unset" ] ; then
X	echo "replication not set up - primary unset" | tee -a $as_log $silence
X	exit 1
Xfi
X	
X#
X# ok, now we know that we are a failed-over primary, and there may be an
X# old primary that may re-appear.  if it does, shoot it, and kick it hard 
X# so it stays down.
X#
X
Xecho "assassin committed" | tee -a $as_log $silence
X
Xecho $$ >$ASSASSIN
X
Xloops=0
Xwhile true ; do
X	if [ $loops -gt 0 ] ; then
X		sleep 60;
X	fi
X	(( loops ++ ))
X
X	#
X	# brutally shoot down the appserver, as we don't want to confuse the
X	# load balancer.  this cannot wait.
X	# 
X	echo "  -- killing appserver unconditionally on $primary" >> $as_log
X	ssh $primary pkill -9 -f "$APPD_ROOT/.*/java -cp $APPD_ROOT/.*glassfish"
X
X	#
X	# if the local database becomes primary, we don't need to run anymore.
X	#
X	type=`sql localhost \
X		 "select * from global_configuration_local where name = 'ha.controller.type'\G" | awk '/value:/ { print $2}'`
X	if [ "$type" == "primary" ] ; then
X		echo "assassin disabled" | tee -a $as_log $silence
X		exit 1
X	fi
X
X	#
X	# if we can't get through, no point doing real work for now. loop
X	#
X	if ! ssh $primary date >/dev/null 2>&1 ; then
X		continue;
X	fi
X
X	#
X	# make sure skip-slave-start is in db.cnf
X	# this is to prevent log reads from the real primary if the db is restarted
X	#
X	cat <<- 'DISABLE' | ssh $primary ex -s $DBCNF >/dev/null 2>&1
X		g/^skip-slave-start/d
X		$a
X		skip-slave-start=true
X		.
X		wq
X	DISABLE
X	if ! ssh $primary grep -q skip-slave-start $DBCNF ; then
X		echo "skip-slave-start insert failed" | tee -a $as_log $silence
X		continue;
X	fi
X
X	#
X	# as replication is broken, stop the DB - no point keeping it up
X	#
X	echo "  -- stop database on $primary" >> $as_log
X	remservice -tq $primary appdcontroller-db stop >> $as_log 2>&1
X
X	#
X	# and stay down.  this prevents inadvertently starting anything.
X	# re-run replication to allow startup.
X	#
X	echo "  -- persistently disabling appserver on $primary" >> $as_log
X	ssh $primary mv -f $APPD_ROOT/bin/controller.sh \
X		$APPD_ROOT/bin/controller.sh-disabled | tee -a $as_log $silence
X	ssh $primary chmod 0 $APPD_ROOT/bin/controller.sh-disabled | tee -a $as_log $silence
X
X	# 
X	# now mark our job done
X	#
X	sql localhost "update global_configuration_local set value='primary' where name = 'ha.controller.type';"
X	echo "assassin exiting - old primary killed" >> $as_log
X	rm -f $ASSASSIN
X	exit 0
X
Xdone
X
X#
X# script end
X#
X
END-of-assassin.sh
echo x - failover.sh
sed 's/^X//' >failover.sh << 'END-of-failover.sh'
X#!/bin/bash
X#
X# $Id: failover.sh 2.13 2016-05-25 18:29:58 rob.navarro $
X#
X# failover.sh
X# run on the passive node, activate this HA node.
X# 
X# if run with the -f option, force failover
X#
X# this may need editing to conform with your controller install
X#
Xdbuser=root
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd -P)
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X	#shldignore		# stop Makefile trying to embed the next source file
X        . $FUNCLIB
Xelse
X        echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X        exit 1
Xfi
X
Xdbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xdbport=`grep ^DB_PORT $APPD_ROOT/bin/controller.sh | cut -d = -f 2`
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=$dbuser --password=$dbpasswd --port=$dbport"
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xif [ -f /sbin/service ] ; then
X    service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X    service_bin=/usr/sbin/service
Xelse
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 13
Xfi
X
Xfo_log=$APPD_ROOT/logs/failover.log
X
X#
X# worker function for sql timer
X#
Xfunction sqltimeout {
X        if [ $sqlpid -ne 0 ] ; then
X                echo "killing sql pid $sqlpid"
X                disown $sqlpid
X                kill -9 $sqlpid
X                sqlpid=0
X                sqlkiller=0
X        fi
X}
X
X#
X# args:  hostname command [ timeout ]
X# sql wrapper - knows about timeout - returns 0 on success, nonzero otherwise
X#
Xfunction sql {
X		echo sql $1 "$2" $3 >> $fo_log
X        if [ $# -lt 3 ] ; then
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller
X        else
X                trap sqltimeout SIGALRM
X                tmpfile=/tmp/failover.sql.$$
X                rm -f $tmpfile
X                DELFILES=$tmpfile
X                mypid=$$
X                (sleep $3 ; kill -SIGALRM $mypid) &
X                sqlkiller=$!
X                disown $sqlkiller
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller > $tmpfile &
X                sqlpid=$!
X                wait $sqlpid
X                retval=$?
X                if [ $sqlkiller -ne 0 ] ; then
X                        kill -9 $sqlkiller
X                fi
X                cat $tmpfile
X                rm -f $tmpfile
X                DELFILES=
X                return $retval
X        fi
X}
X
Xfunction bounce_slave {
X	sql localhost "stop slave ; start slave ;" >> $fo_log
X}
X
Xfunction slave_status {
X	bounce_slave
X
X	# wait for the slave to settle
X	connect_count=0
X
X	while [ $connect_count -lt 3 ] ; do
X		eval `sql localhost "show slave status\G" | awk '
X			BEGIN { OFS="" }
X			/Slave_IO_Running:/ {print "slave_io=",$2}
X			/Slave_SQL_Running:/ {print "slave_sql=",$2}
X			/Seconds_Behind_Master:/ {print "seconds_behind=",$2}
X			/Master_Host:/ {print "primary=",$2}
X		'`
X		case "$slave_io" in
X		Connecting) 
X			(( connect_count++ ))
X			sleep 10
X			continue;
X			;;
X		Yes) break
X			;;
X		No) break
X			;;
X		esac
X	done
X}
X
X# abstract out the privilege escalation
Xif [[ `id -u` == 0 ]] ; then
X	function service {
X		$service_bin $1 $2
X	}
X
X	function remservice {
X		ssh $1 $2 $service_bin $3 $4
X	}	
Xelse
X	if [ -x /sbin/appdservice ] ; then
X		function service {
X			/sbin/appdservice $1 $2
X		}
X		function remservice {
X			ssh $1 $2 /sbin/appdservice $3 $4
X		}	
X	else
X		function service {
X			sudo $service_bin $1 $2
X		}
X		function remservice {
X			ssh $1 $2 sudo $service_bin $3 $4
X		}	
X	fi
Xfi
X
X#
X# parse arguments
X#
Xforce=false
X
Xwhile getopts f flag; do
X	case $flag in
X	f)
X		force=true
X		;;
X	*)
X		echo "usage: $0 <options>"
X		echo "    [ -f ] force replication break"
X		exit
X		;;
X	esac
Xdone
X
Xecho "  -- failover log" `date` >> $fo_log
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $fo_log
X	exit 1
Xfi
Xif [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X	echo db configuration $APPD_ROOT/db is not a directory | tee -a $fo_log
X	exit 1
Xfi
Xif [ ! -x "$MYSQL" ] ; then
X	echo controller root $MYSQL is not executable | tee -a $fo_log
X	exit 1
Xfi
X
X#
X# we must be the passive node
X#
Xecho "  -- Verify passive node" | tee -a $fo_log
Xmode=`sql localhost \
X "select * from global_configuration_local where name = 'appserver.mode'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$mode" == "active" ] ; then
X	echo "this script must be run on the passive node" | tee -a $fo_log
X	exit 1
Xfi
X
X#
X# we must be replicating
X#
Xecho "  -- Verify replication state" | tee -a $fo_log
Xslave=`sql localhost \ "show slave status\G" | wc -l`
Xif [ "$slave" = 0 ] ; then
X	echo "replication is not running" | tee -a $fo_log
X	if [ $force != "true" ] ; then
X		exit 1
X	else
X		echo "  -- Force Failover even with no slave" | tee -a $fo_log
X		primary_up=false
X	fi
Xfi
X
X#
X# replication must be moderately healthy - it's ok if the other server is down
X#
Xslave_status
Xif [ "$slave_sql" != "Yes" ] ; then
X	echo slave SQL not running - replication error | tee -a $fo_log
X	if [ $force != "true" ] ; then
X		exit 1
X	else
X		echo "  -- Force Failover - stopped slave" | tee -a $fo_log
X		primary_up=false
X	fi
Xfi
Xcase "$slave_io" in 
X	"Yes")
X		primary_up=true
X		;;
X	"Connecting")
X		primary_up=false
X		echo "  -- Primary DB not running" | tee -a $fo_log
X		;;
X	*)
X		echo "Unrecognized state for slave IO: $slave_io" | tee -a $fo_log
X		if [ "$force" != true ] ; then
X			exit 1
X		else
X			echo "  -- Force Failover - unknown slave state" | tee -a $fo_log
X			primary_up=false
X		fi
X		;;
Xesac
X
X#####
X#
X# at this point, we are committed to failing over
X#
X
X#
X# kill the local watchdog if it is up
X#
Xkc=0
Xwhile [ -f $WATCHDOG ] ; do
X	if [ $(($kc % 10)) -eq 0 ] ; then
X		kill `cat $WATCHDOG` >/dev/null 2>&1
X		echo "  -- Kill Watchdog" | tee -a $fo_log
X	fi
X	let kc++
X	sleep 1
Xdone
X
X#
X# kill the local appserver if it's running
X#
Xecho "  -- Kill Local Appserver" | tee -a $fo_log
Xservice appdcontroller stop >> $fo_log 2>&1
X
X#
X# persistently break replication if the primary is down, 
X# or we want to force a replication break
X#
Xif [ "$force" == true -o "$primary_up" == false ] ; then
X	echo "  -- Disable local slave autostart" | tee -a $fo_log
X
X	#
X	# disable automatic start of replication slave
X	# edit the db.cnf to remove any redundant entries for skip-slave-start
X	# this is to ensure that replication does not get turned on by a reboot
X	#
X	ex -s $DBCNF <<- 'DISABLE'
Xg/^skip-slave-start/d
X$a
Xskip-slave-start=true
X.
Xwq
XDISABLE
X	#
X	# now stop the replication slave
X	#
X	echo "  -- Stop local slave " | tee -a $fo_log
X	sql localhost "stop slave;"
Xfi
X
X#
X# if the primary is up, mark it passive, and stop the appserver
X# also, if the old primary is not reachable, ha.controller.type will be changed by the assassin when it finally makes contact.
X#
Xif [ "$primary_up" = "true" ] ; then
X	echo "  -- Stop primary appserver" | tee -a $fo_log
X	remservice -tq $primary appdcontroller stop >> $fo_log 2>&1
X	echo "  -- Mark primary passive + secondary" | tee -a $fo_log
X	if sql $primary "update global_configuration_local set value='passive' where name = 'appserver.mode';" 10 &&
Xsql $primary "update global_configuration_local set value='secondary' where name = 'ha.controller.type';" 10 ; then
X		echo "  -- Mark local primary" | tee -a $fo_log
X		sql localhost "update global_configuration_local set value='primary' where name = 'ha.controller.type';"
X	else
X		echo "  -- Primary DB timeout" | tee -a $fo_log
X		break_replication=true
X	fi
X	if [ "$break_replication" == true ] ; then
X		primary_up=false
X		echo "  -- Stop secondary database" | tee -a $fo_log
X		remservice -tq $primary appdcontroller-db stop >> $fo_log 2>&1
X		ssh -tq $primary ex -s $DBCNF <<- 'DISABLEP'
Xg/^skip-slave-start/d
X$a
Xskip-slave-start=true
X.
Xwq
XDISABLEP
X	fi
Xfi
X
X#
X# the primary is now down and maybe passive; 
X# it is now safe to mark our node active and start the appserver
X#
Xecho "  -- Mark local active" | tee -a $fo_log
Xecho "  -- Starting local Controller" | tee -a $fo_log
Xsql localhost "update global_configuration_local set value='active' where name = 'appserver.mode';"
X#
X# this will start the assassin if needed.
Xservice appdcontroller start >> $fo_log 2>&1
X
X#
X# if the other side was ok, then we can start the service in passive mode
X#
Xif [ "$primary_up" = "true" ] ; then
X	echo "  -- start passive secondary" | tee -a $fo_log
X	remservice -nqf $primary appdcontroller start | tee -a $fo_log 2>&1 &
Xfi
X
Xecho "  -- Failover complete" | tee -a $fo_log
X
Xexit 0
X#
X# script end
X#
X
END-of-failover.sh
echo x - watchdog.sh
sed 's/^X//' >watchdog.sh << 'END-of-watchdog.sh'
X#!/bin/bash
X#
X# $Id: watchdog.sh 2.14 2016-05-25 18:37:30 rob.navarro $
X#
X# watchdog.sh
X# run on the passive node, fail over if we see the primary is very sick
X# if we are not capable of failing over, fall over immediately
X
X#
X# this is needed to set the output of a pipe to the first failing process
X#
Xset -o pipefail
X
X#
X# skip SSL certificate validation when doing health checks, ( useful for 
X# self-signed certificates, and certs issued by internal, corporate CAs )
X# leave empty to require certificate validation against the host's CA cert bundle
X#
X
XCERT_VALIDATION_MODE="-k"
X
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd -P)
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X	#shldignore		# stop Makefile trying to embed the next source file
X        . $FUNCLIB
Xelse
X        echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X        exit 1
Xfi
X
Xdbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xdbport=`grep ^port= $APPD_ROOT/db/db.cnf | cut -d = -f 2`
X
X# get all of the ports the controller listens on and determine the accompanying
X# protocols
Xdeclare -a APP_PORT
Xdeclare -a APP_PROTO
X
XIFS=$'\n'
X
Xi=0
Xfor n in $( echo "cat /domain/configs/config[@name='server-config']/network-config/network-listeners/network-listener[@name!='admin-listener' and @name!='controller-config-listener']" | \
X	xmllint --shell $DOMAIN_XML | grep \<network-listener ) ; do
X	APP_PORT[$i]=$(echo "$n" | sed -re 's/^.*port="([0-9]+)".*$/\1/')
X	protocol_name=$(echo "$n" | sed -re 's/^.*protocol="([^"]+)".*$/\1/')
X	
X	if echo "cat /domain/configs/config[@name='server-config']/network-config/protocols/protocol[@name='$protocol_name']/attribute::security-enabled" | xmllint --shell $DOMAIN_XML | grep -q 'security-enabled="true"' ; then
X		APP_PROTO[$i]=https
X	else
X		APP_PROTO[$i]=http
X	fi
X	((i++))
Xdone
XIFS=\ 
X
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
XRUNUSER=`awk -F= '/^[\t ]*user=/ {print $2}' $APPD_ROOT/db/db.cnf`
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XMYSQLADMIN="$APPD_ROOT/db/bin/mysqladmin"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=root --password=$dbpasswd --port=$dbport"
XWATCHDOG_ENABLE=$APPD_ROOT/HA/WATCHDOG_ENABLE
XWATCHDOG_SETTINGS=$APPD_ROOT/HA/watchdog.settings
XWATCHDOG_STATUS=$APPD_ROOT/logs/watchdog.status
X
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xfo_log=$APPD_ROOT/logs/failover.log
Xwd_log=$APPD_ROOT/logs/watchdog.log
Xwd_tmp=/tmp/wd_curl.out.$$
X
X# 
X# These are the default timeouts, in seconds, before the watchdog will
X# initiate a failover.  If they are set to low, they can cause unexpected
X# failover events and controller downtime.  The following defaults are very
X# conservative and should be overridden with site-specific settings in
X# $APPD_ROOT/HA/watchdog.settings
X
X# Controller app server not reachable via HTTP(S):  5 Minutes
XDOWNLIMIT=300
X
X# Controller app server shutting down: 5 Minutes
XFALLINGLIMIT=300
X
X# Controller app server starting up: 60 Minutes
XRISINGLIMIT=3600
X
X# The primary database is not responding: 5 Minutes
XDBDOWNLIMIT=300
X
X# The primary database cannot create a table: 2 Minutes
XDBOPLIMIT=300
X
X# The active controller host is not responding to ICMP echo, (ping),
X# requests: 5 Minutes
XPINGLIMIT=300
X
X#
X# the length of time to wait for a sql statememt to run
XDBWAIT=10
X
X#
X# polling frequency
X#
XLOOPTIME=10
X
X#
X# Time to wait for a ping response
X#
XPINGTIME=2
X
X#
X# Time for curl to wait for a complete response from the controller
X#
XCURL_MAXTIME=2
X
X#
X# Time to wait between consecutive requests to create a dummy table on remote
X#
XDB_CREATE_DELAY=10
X
Xlast_db_create=0
X
X#
X# remove the watchdog pid and temporary curl output file when we exit
X#
Xfunction cleanup () {
X	echo `date` "watchdog exit" >> $wd_log
X	rm -f $WATCHDOG $wd_tmp $DELFILES
X}
X
X#
X# worker function for sql timer
X#
Xfunction sqltimeout {
X	if [ $sqlpid -ne 0 ] ; then
X		echo "killing sql pid $sqlpid"
X		disown $sqlpid
X		kill -9 $sqlpid
X		sqlpid=0
X		sqlkiller=0
X	fi
X}
X
X#
X# args:  hostname command [ timeout ]
X# sql wrapper - knows about timeout - returns 0 on success, nonzero otherwise
X#
Xfunction sql {
X	if [ $# -lt 3 ] ; then
X		echo "$2" | $MYSQL --host=$1 $CONNECT controller
X	else
X		trap sqltimeout SIGALRM
X		tmpfile=/tmp/watchdog.sql.$$
X		rm -f $tmpfile
X		DELFILES=$tmpfile
X		mypid=$$
X		(sleep $3 ; kill -SIGALRM $mypid) &
X		sqlkiller=$!
X		disown $sqlkiller
X		echo "$2" | $MYSQL --host=$1 $CONNECT controller > $tmpfile &
X		sqlpid=$!
X		wait $sqlpid
X		retval=$?
X		if [ $sqlkiller -ne 0 ] ; then
X			kill -9 $sqlkiller
X		fi
X		cat $tmpfile
X		rm -f $tmpfile
X		DELFILES=
X		return $retval
X	fi
X}
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xfunction sanity {
X	if [ ! -d "$APPD_ROOT" ] ; then
X		echo $APPD_ROOT is not a directory >> $wd_log
X		return 0
X	fi
X	if [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X		echo $APPD_ROOT/db/db.cnf is not a directory >> $wd_log
X		return 0
X	fi
X	if [ ! -x "$MYSQL" ] ; then
X		echo controller root $MYSQL is not executable >> $wd_log
X		return 0
X	fi
X
X	#
X	# the watchdog enable file must exist.
X	#
X	if [ ! -f $WATCHDOG_ENABLE ] ; then
X		echo watchdog disabled
X		return 0
X	fi
X
X	#
X	# we must be the passive node
X	#
X	mode=`sql localhost \
X	 "select * from global_configuration_local where name='appserver.mode'\G" |
X	 awk '/value:/ { print $2}'`
X	if [ "$mode" == "active" ] ; then
X		echo "this script must be run on the passive node" >> $wd_log
X		return 0
X	fi
X
X	#
X	# we must be replicating
X	#
X	slave=`sql localhost \ "show slave status\G" | wc -l`
X	if [ "$slave" = 0 ] ; then
X		echo "replication is not running" >> $wd_log
X		return 0
X	fi
X
X	#
X	# replication must be moderately healthy - it's ok if the primary is down
X	#
X	eval `sql localhost \ "show slave status\G" | awk '
X		BEGIN { OFS="" }
X		/Slave_IO_Running:/ {print "slave_io=",$2}
X		/Slave_SQL_Running:/ {print "slave_sql=",$2}
X		/Seconds_Behind_Master:/ {print "seconds_behind=",$2}
X		/Master_Host:/ {print "primary=",$2}
X	'`
X	if [ "$slave_sql" != "Yes" ] ; then
X		echo slave SQL not running - replication error >> $wd_log
X		return 0
X	fi
X	case "$slave_io" in 
X		"Yes")
X			primary_up=true
X			;;
X		"Connecting")
X			primary_up=false
X			echo "  -- Primary DB not running" >> $wd_log
X			;;
X		*)
X			echo "Unrecognized state for slave IO: $slave_io" >> $wd_log
X			return 0
X			;;
X	esac
X	return 1
X}
X
X#
X# code to do a rest call for status. 
X#
Xfunction serverstatus {
X	local app_proto=$1
X	local app_port=$2
X	STATUS="$app_proto://$primary:$app_port/controller/rest/serverstatus"
X	curl -m $CURL_MAXTIME -fsS $CERT_VALIDATION_MODE $STATUS > $wd_tmp 2>&1
X	curlstat=$?
X	case "$curlstat" in
X	0)
X		echo good
X		;;
X	7)
X		echo "down"
X		echo "curl error 7" >> $wd_log
X		;;
X	22)
X		eval `awk '/(22)/ {printf("http_code=%d\n", $8);}' < $wd_tmp`
X		echo "curl error 22: $http_code" >> $wd_log
X		cat $wd_tmp >> $wd_log
X		case $http_code in
X		503)
X			echo "falling"
X			;;
X		500)
X			echo "rising"
X			;;
X		404)
X			echo "rising"
X			;;
X		*)
X			echo "other"
X			;;
X		esac
X		;;
X	28)
X		echo "down"
X		echo "curl error 28: operation timed out" >> $wd_log
X		;;
X	35)
X		echo "down"
X		echo "curl error 35" >> $wd_log
X		;;
X	52)
X		echo "no data"
X		echo "curl error 52" >> $wd_log
X		;;
X	*)
X		echo "other"
X		echo "curl error $curlstat" >> $wd_log
X		;;
X	esac
X}
X
X#
X# pass the variable, and limit
X#
X# warning: gnarly shell syntax and usage
X#
Xfunction expired () {
X	if [ ${!1} -eq 0 ] ; then
X		eval "$1=`date +%s`"
X	fi
X	now=`date +%s`
X	limit=$((${!1} + $2))
X	left=$(($limit - $now))
X	echo `date` "expired $1 ${!1} $limit $left $2" >> $wd_log
X	echo "   timer $1 start $limit left $left limit $2" > $WATCHDOG_STATUS
X	if [ `date +%s` -gt $((${!1} + $2)) ] ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
X#
X# our exceptional state loop
X# 
X# here is where we test primary health and return when something happens
X# for long enough
Xfunction poll {
X	local i=0
X
X	downtime=0
X	risingtime=0
X	fallingtime=0
X	pingfail=0
X	dbfail=0
X	dbopfail=0
X
X	rm -f $WATCHDOG_STATUS
X
X	while true ; do
X		#
X		# if somebody removed the watchdog file, stop watching
X		#
X		if [ ! -f $WATCHDOG_ENABLE ] ; then
X			echo watchdog newly disabled >> $wd_log
X			return 0
X		fi
X		
X		#
X		# first, ping the primary.  
X		# occasionally, ICMP is disabled, so PING can be disabled
X		#
X		if [ "$PINGLIMIT" = "0" ] ; then
X			pingfail=0
X		else
X			if ping -c 1 -W $PINGTIME -q $primary >/dev/null 2>&1 ; then
X				pingfail=0
X			else
X				if expired pingfail $PINGLIMIT ; then
X					echo `date` pingfail expired >> $wd_log
X					return 2
X				fi
X				# we can't even ping.  Sleep for $((LOOPTIME-PINGTIME)) then try again
X				sleep $((LOOPTIME-PINGTIME))
X				continue
X			fi
X		fi
X
X		#
X		# then, is the primary database up listening
X		#
X		if $MYSQLADMIN --host=$primary $CONNECT ping >/dev/null 2>&1 ; then
X			dbfail=0
X		else
X			dbopfail=0
X			downtime=0
X			risingtime=0
X			fallingtime=0
X			pingfail=0
X			if expired dbfail $DBDOWNLIMIT ; then
X				echo `date` dbfail expired >> $wd_log
X				return 2
X			fi
X			sleep $LOOPTIME
X			continue
X		fi
X
X		#
X		# then, is the database capable of doing some real work for us
X		# only do this every DB_CREATE_DELAY
X		#
X		if [ $(($last_db_create+$DB_CREATE_DELAY)) -le `date +%s` ] ; then
X			last_db_create=`date +%s`
X			if 
Xsql $primary "drop table if exists watchdog_test_table;" $DBWAIT &&
Xsql $primary "create table watchdog_test_table (i int);" $DBWAIT &&
Xsql $primary "insert into watchdog_test_table values (1);" $DBWAIT &&
Xsql $primary "select count(*) from watchdog_test_table;" $DBWAIT &&
Xsql $primary "drop table watchdog_test_table;" $DBWAIT ; then
X				dbopfail=0
X			else
X				dbfail=0
X				downtime=0
X				risingtime=0
X				fallingtime=0
X				pingfail=0
X				if expired dbopfail $DBOPLIMIT ; then
X					echo `date` dbopfail expired >> $wd_log
X					return 2
X				fi
X				sleep $LOOPTIME
X				continue
X			fi
X		fi
X
X		#
X		# how does the appserver respond to a serverstatus REST?
X		# if down, try every port before calling expired()
X		#
X		status=`serverstatus ${APP_PROTO[$i]} ${APP_PORT[$i]}`
X		case $status in
X		down)
X			if [ $i -lt $((${#APP_PROTO[@]}-1)) ] ; then
X				((i++))
X				continue
X			else
X				i=0
X			fi
X			risingtime=0
X			fallingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X			if expired downtime $DOWNLIMIT ; then
X				echo `date` downtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		rising)
X			# reset the other timers
X			downtime=0
X			fallingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X
X			if expired risingtime $RISINGLIMIT ; then
X				echo `date` risingtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		falling)
X			downtime=0
X			risingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X			if expired fallingtime $FALLINGLIMIT ; then
X				echo `date` fallingtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		good)
X			return 0
X			;;
X		*)
X			echo `date` "unknown status $status" >> $wd_log
X			return 1
X			;;
X		esac
X		
X		sleep $LOOPTIME
X	done
X}
X
X#
X# begin actual code
X#
Xif [ `id -un` != "$RUNUSER" ] ; then
X	echo watchdog must run as $RUNUSER
X	exit 1
Xfi
X
X#
X# only run one watchdog
X#
Xif [ -f "$WATCHDOG" ] ; then
X	WATCHPID=`cat $WATCHDOG`
X	if [ ! -z "$WATCHPID" ] ; then
X		if kill -0 $WATCHPID 2>/dev/null ; then
X			echo watchdog already running
X			exit 1
X		fi
X	fi
Xfi
X
X#
X# we are starting to run. register
X#
Xtrap cleanup EXIT
Xrm -f $WATCHDOG
Xecho $$ > $WATCHDOG
X
X#
X# overrides, so we don't have to edit this file
X#
Xif [ -f $WATCHDOG_SETTINGS ] ; then
X	source $WATCHDOG_SETTINGS
Xfi
X
X#
X# force first report
X#
Xlaststatus=1
X
X#
X# our main loop.  every time the controller is noted up, we start from scratch.
X#
Xwhile true ; do
X	if [ ! -f $wd_log ] ; then
X		echo "  -- watchdog log " `date` > $wd_log
X		echo "  -- settings: down:$DOWNLIMIT falling:$FALLINGLIMIT \
X rising:$RISINGLIMIT dbdown:$DBDOWNLIMIT ping:$PINGLIMIT loop:$LOOPTIME" >> $wd_log
X	fi
X	if sanity ; then
X		if [ -f $WATCHDOG_ENABLE ] ; then
X			echo "failover not possible" | tee -a $wd_log
X		fi
X		echo "watchdog exiting" | tee -a $wd_log
X		exit 1
X	fi
X
X	poll
X	pollstatus=$?
X	case $pollstatus in
X	0)
X		# don't report consecutive good to minimize noise
X		if [ $laststatus != '0' ] ; then
X			date >> $wd_log
X			echo "watchdog good" >> $wd_log
X		fi
X		;;
X	2)
X		date >> $wd_log
X		echo "failover invoked" >> $wd_log
X		$APPD_ROOT/HA/failover.sh >> $fo_log 2>&1 &
X		exit 0
X		;;
X	1|*)
X		date >> $wd_log
X		echo "watchdog abort poll status = $pollstatus" >> $wd_log
X		exit 1
X		;;
X	esac
X	sleep $LOOPTIME
X	laststatus=$pollstatus
Xdone
X
X#
X# script end
X#
END-of-watchdog.sh
echo x - watchdog.settings.template
sed 's/^X//' >watchdog.settings.template << 'END-of-watchdog.settings.template'
X# $Id: watchdog.settings.template 1.5 2015-12-23 00:36:28 cmayer $
X#
X# watchdog.settings
X
X# 
X# These are the default timeouts, in seconds, before the watchdog will
X# initiate a failover.  If they are set to low, they can cause unexpected
X# failover events and controller downtime.  The following defaults are very
X# conservative and should be overridden with site-specific settings by
X# copying this file to $APPD_ROOT/HA/watchdog.settings and editing
X# it appropriately.
X
X# Controller app server not reachable via HTTP(S):  5 Minutes
XDOWNLIMIT=300
X
X# Controller app server shutting down: 5 Minutes
XFALLINGLIMIT=300
X
X# Controller app server starting up: 60 Minutes
XRISINGLIMIT=3600
X
X# The primary database is not responding: 5 Minutes
XDBDOWNLIMIT=300
X
X# The active controller host is not responding to ICMP echo, (ping),
X# requests: 5 Minutes
X# if ICMP is disabled, PING can be disabled by setting PINGLIMIT to 0
XPINGLIMIT=300
X
X# The primary database cannot create a table: 2 Minutes
XDBOPLIMIT=300
X
X#
X# the length of time to wait for a sql statememt to run
XDBWAIT=10
X
X
END-of-watchdog.settings.template
echo x - replicate.sh
sed 's/^X//' >replicate.sh << 'END-of-replicate.sh'
X#!/bin/bash
X#
X# $Id: replicate.sh 2.27 2016-05-25 18:36:12 rob.navarro $
X#
X# install HA to a controller pair
X#
X# this must be run on the primary, and ssh and rsync must be set up 
X# on both machines.
X#
X# if replication isn't broken before you run this, it certainly will be
X# during.
X#
X# this has very limited sanity checking, so please be very careful.
X#
Xprimary=`hostname`
Xinternal_vip=
Xexternal_vip=
Xcontroller_monitor=
Xsecondary=
Xdef_APPD_ROOT=$(cd $(dirname "$0"); cd .. ; pwd -P)
XAPPD_ROOT=$def_APPD_ROOT
Xdbport=`grep ^port= $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xdatadir=
Xinnodb_logdir=
Xupgrade=
Xfinal=false
XDEBUGCMD=""
Xrunning_as_root=$( [[ $(id -u) -eq 0 ]] && echo "true" || echo "false" )
X#
X# the services in this list must appear in the order in which they should be
X# stopped
X#
Xappdynamics_service_list=( appdcontroller appdcontroller-db )
X
Xtmpdir=/tmp/ha.$$
X
Xrsync_opts="-PavpW --del --inplace --exclude=ibdata1 --exclude=ib_logfile* --exclude=lost+found"
Xfinal_rsync_opts="-PavpW --del --inplace --exclude=lost+found"
Xrsync_throttle="--bwlimit=20000"
Xstart_appserver=true
Xwatchdog_enable=false
Xrsync_compression=""
Xwildcard=
X
Xif [ -f /sbin/service ] ; then
X	service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X	service_bin=/usr/sbin/service
Xelse 
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 13
Xfi
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X	#shldignore		# stop Makefile trying to embed the next source file
X        . $FUNCLIB
Xelse
X        echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X        exit 1
Xfi
X
X# ensure the functions have automated access to MySQL root passwd
XMYSQL_ROOT_PASSWD=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xexport MYSQL_ROOT_PASSWD
X
X# helper function to join array elements into string with named separator,
X# gleaned from:
X# http://stackoverflow.com/questions/1527049/bash-join-elements-of-an-array
X# Call as:
X#  fjoin : a b c
Xfunction fjoin {
X   	local IFS="$1"
X   	shift
X   	echo "$*"
X}
X
X# simplifies processing domain.xml for properties that may not be included
X# by default. They are either inserted with given value or updated to given value
Xfunction upsert {
X	(( $# == 2 )) || err "upsert: needs two args"
X
X	local property=$1
X	local value=$2
X	local domain_xml=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
X	if grep -q -- "$1" $domain_xml ; then		# property already present with some value
X		ex -s $domain_xml <<- EOT
X			%s/\($property=\)[^<]*/\1$value/
X			wq
X		EOT
X	else						# property not present
X		ex -s $domain_xml << EOT
X/-Dappdynamics.controller.port/a
X	<jvm-options>$property=$value</jvm-options>
X.
Xwq
XEOT
X	fi
X}
X
X# wrapping bag of portable checks for installed service
Xfunction check_installed_service {
X   	eval $DEBUGCMD
X   	(( $# == 1 )) || err "check_installed_service: needs 1 arg"
X	
X   	local svc_name=$1
X   	local chkconfig=$(which /sbin/chkconfig 2>/dev/null)		# returns path if exists
X   	local lservice=$service_bin
X
X   	[[ -f /etc/init.d/$svc_name ]] || return 1
X	
X   	if [[ -n "$chkconfig" ]] ; then
X		return $($chkconfig --list $svc_name >/dev/null 2>&1)
X   	fi
X
X   	return $($lservice --status-all 2>/dev/null| grep -q '\b'$svc_name'\b')
X}
X
X# wrapping bag of portable checks for installed remote service
Xfunction remote_check_installed_service {
X   	eval $DEBUGCMD
X   	(( $# == 2 )) || err "check_installed_service: needs 2 args"
X
X   	local host=$1
X   	local svc_name=$2
X   	local chkconfig=$(ssh -q $host "which /sbin/chkconfig" 2>/dev/null)
X   	local lservice=$service_bin
X
X   	ssh -tq $host "bash -c '[[ -f /etc/init.d/$svc_name ]]'" || return 1
X
X   	if [[ -n "$chkconfig" ]] ; then
X      		return $(ssh -tq $host "$chkconfig --list $svc_name >/dev/null 2>&1")
X   	fi
X
X   	return $(ssh -q $host "$lservice --status-all 2>/dev/null" | grep -qw "$svc_name")
X}
X
X# verify that a required executable / package is installed
X# complain and return 1 if not
X# local and remote
Xfunction require() {
X	ret=0
X	# args: executable "redhat package" "debian package" 
X	if ! [[  -x `which $1 2>/dev/null` ]] ; then
X		echo "Unable to find $1 in $PATH"
X		echo "Please install with:"
X		if [[ -x `which apt-get 2>/dev/null` ]] ; then
X			echo "apt-get update && apt-get install $3"
X		elif [[ -x `which yum 2>/dev/null` ]] ; then
X			echo "yum install $2"
X		fi
X		ret=1
X	fi
X	if ! ssh -tq $secondary which $1 2>&1 >/dev/null ; then
X		echo "Unable to find $1 in $PATH on $secondary"
X		echo "Please install with:"
X		if ssh $secondary which apt-get 2>&1 >/dev/null ; then
X			echo "apt-get update && apt-get install $3"
X		elif ssh $secondary which yum 2>&1 >/dev/null ; then
X			echo "yum install $2"
X		fi
X		ret=1
X	fi
X	return $ret
X}
X
X
X# execute remote service operation
X# args:  flags machine service verb
Xfunction remservice {
X	eval $DEBUGCMD
X	if [ `id -u` == 0 ] ; then
X		ssh $1 $2 $service_bin $3 $4
X	else
X		if ssh $2 test -x /sbin/appdservice ; then
X			ssh $1 $2 /sbin/appdservice $3 $4
X		else
X			ssh $1 $2 sudo -n $service_bin $3 $4
X		fi
X	fi
X}
X
X# execute service operation
X# args: service verb
Xfunction service {
X	eval $DEBUGCMD
X	if [ `id -u` == 0 ] ; then
X		$service_bin $1 $2
X	else
X		if [ -x /sbin/appdservice ] ; then
X			/sbin/appdservice $1 $2
X		else
X			sudo -n $service_bin $1 $2
X		fi
X	fi
X}
X
Xfunction help()
X{
X	if [ -f README ] ; then
X		if [ -n "$PAGER" ] ; then
X			$PAGER README
X		else
X			cat README
X		fi
X	fi
X}
X
Xfunction stop_appdynamics_services()
X{
X	local secondary=$1
X	local errors=0
X	for s in ${appdynamics_service_list[@]}
X	do 
X		if [ -z "$secondary" ] ; then
X			service $s stop || ((errors++))
X		else
X			remservice -tq $secondary $s stop || ((errors++))
X		fi
X	done
X	return $errors;
X}
X
Xfunction verify_init_scripts()
X{
X	local secondary=$1
X	local ssh=`[ -n "$secondary" ] && echo "ssh -tq"`
X	local errors=0
X	local NEWMD5=
X	local converted
X	for s in ${appdynamics_service_list[@]}
X	do 
X		converted=$(convert_init_script $APPD_ROOT/HA/$s.sh) || exit 1	# catch conversion errors
X		NEWMD5=$(md5sum <<< "$converted" | cut -d " " -f 1)
X		if [[ "$NEWMD5" != `$ssh $secondary md5sum /etc/init.d/$s|cut -d " " -f 1` ]] ; then
X			((errors++))
X		fi
X	done
X	if [ $errors -gt 0 ] ; then
X		if [ -z $secondary ] ; then
X			echo "\
XOne or more AppDynamics init scripts are not installed or are out of date.
XPlease run $APPD_ROOT/HA/install-init.sh as root before proceeding."
X		else
X			echo "\
XOne or more AppDynamics init scripts are not installed or are out of date on
X$secondary. Please run $APPD_ROOT/HA/install-init.sh as root on $secondary
Xbefore proceeding."
X		fi
X	fi
X	return $errors;
X}
X
Xfunction get_privilege_escalation(){
X	local secondary=$1
X	local ssh=`[ -n "$secondary" ] && echo "ssh -tq"`
X	local escalation_type=
X	local errors=0
X	for s in ${appdynamics_service_list[@]}
X	do 
X		if $ssh $secondary test -x /sbin/appdservice ; then
X			if dd if=/sbin/appdservice bs=11 count=1 2>/dev/null \
X				| grep -q '^#!/bin/bash' ; then
X				escalation_type="pbrun"
X			else
X				escalation_type="setuid"
X			fi
X		else
X			$ssh $secondary sudo -nl $service_bin $s start > /dev/null 2>&1 || ((errors++))
X			$ssh $secondary sudo -nl $service_bin $s stop > /dev/null 2>&1 || ((errors++))
X			if  [ $errors -lt 1 ] ; then
X				escalation_type="sudo"
X			else
X				escalation_type="unknown"
X			fi
X		fi
X	done
X	echo $escalation_type
X	return $errors
X}
X
Xfunction verify_privilege_escalation(){
X	local secondary=$1
X	local errors=0
X	local local_priv_escalation=
X	local remote_priv_escalation=
X
X	local_priv_escalation=$(get_privilege_escalation)
X	if [ $? -gt 0 ] ; then
X		echo "\
XUser $RUNUSER is unable to start and stop appdynamics services
XPlease ensure that $APPD_ROOT/HA/install-init.sh has been run."
X		((errors++))
X	fi
X
X	remote_priv_escalation=$(get_privilege_escalation $secondary)
X	if [ $? -gt 0 ] ; then
X		echo "\
XUser $RUNUSER is unable to start and stop appdynamics services on $secondary.
XPlease ensure that $APPD_ROOT/HA/install-init.sh has been run on $secondary."
X		((errors++))
X	fi
X	
X	if [ $errors -lt 1 ] && [ "$local_priv_escalation" != "$remote_priv_escalation" ] ; then
X		echo "\
XThe primary and secondary hosts are not using the same privilege escalation
Xwrapper.
X
XPrimary:   $local_priv_escalation
XSecondary: $remote_priv_escalation
X
XPlease re-run install-init.sh on one or both hosts with the same options."
X		((errors++))
X	fi
X	return $errors
X}
X
Xfunction usage()
X{
X	echo "usage: $0 <options>"
X	echo "    -s <secondary hostname>"
X#	echo "    [ -j ] Synchronize controller app server configurations and related binaries"
X#	echo "           if secondary database is running, leave it running."
X	echo "    [ -e [protocol://]<external vip>[:port] ]"
X	echo "    [ -i [protocol://]<internal vip>[:port] ]"
X	echo "    [ -m url=[protocol://]<controller_monitor>[:port],access_key=\"1-2-3-4\"[,app_name=\"ABC controller\"][,account_name=someaccount] ]"
X	echo "    [ -a <machine agent install directory> ]"
X	echo "    [ -c <controller root directory> ]"
X	echo "       default: $def_APPD_ROOT"
X	echo "    [ -f ]       do final install and activation"
X	echo "    [ -t [rsync speed limit]]" if unspecified or 0, unlimited
X#	echo "    [ -u ] upgrade fixup"
X	echo "    [ -n ] no appserver start"
X	echo "    [ -w ] enable watchdog on secondary"
X	echo "    [ -z ] enable rsync compression"
X	echo "    [ -W ] use wildcard host in grant"
X	echo "    [ -D ] output debug logging"
X	echo "    [ -h ] print help"
X	exit 1
X}
X
Xfunction parse_vip()
X{
X	vip_name=$1
X	vip_def=$2
X
X	[[ -z "$vip_def" ]] && return
X
X	echo $vip_def | awk -F: -v vip_name=$vip_name '
X		BEGIN { 
X			host=""; 
X			protocol="http";
X			port="8090"; 
X		}
X		/http[s]*:/ {protocol=$1; host=$2; port=$3;next}
X		/:/ {host=$1; port=$2;next}
X		{host=$1}
X		END {
X			if (port == "") {
X				port = (protocol=="https")?443:8090;
X			}
X			gsub("^//","",host);
X			gsub("[^0-9]*$","",port);
X			printf("%s_host=%s\n", vip_name, host);
X			printf("%s_port=%s\n", vip_name, port);
X			printf("%s_protocol=%s\n", vip_name, protocol);
X		}
X	'
X}
X
Xwhile getopts :s:e:m:a:i:c:dfhjut:nwzFHWD flag; do
X	case $flag in
X	d)
X		debug=true
X		;;
X	s)
X		secondary=$OPTARG
X		;;
X	e)
X		external_vip=$OPTARG
X		;;
X	i)
X		internal_vip=$OPTARG
X		;;
X	m)
X		controller_monitor_args=$OPTARG
X		declare -a vals A
X		declare -A cmargs
X		IFS=, read -a vals <<< "$controller_monitor_args"	# initial parse/split by commas
X		for i in ${!vals[*]} ; do 
X		   IFS="=" read -a A <<< "${vals[$i]}"			# split by '='
X		   noquote=$(sed -e 's/^["'\'']//' -e 's/["'\'']$//' <<< "${A[1]}")	# remove any leading/trailing quotes
X		   cmargs[${A[0]}]=${noquote}				# assign associative
X	        done
X		[[ -n "${cmargs['url']}" ]] 		|| { echo "Missing \"url\" value in -m" 2>&1; usage; }
X		[[ -n "${cmargs['access_key']}" ]] 	|| { echo "Missing \"access_key\" value in -m" 2>&1; usage; }
X		if [[ -z "${cmargs['app_name']}" ]] ; then
X			cmargs["app_name"]="HA $(fjoin - $(sort < <(echo -e "$primary\n$secondary"))) controller"
X		fi
X		[[ -n "${cmargs['account_name']}" ]] 	|| cmargs["account_name"]="customer1"
X		unset vals A
X		controller_monitor="${cmargs['url']}"			# nice name for use elsewhere
X		# declare -p cmargs					# helpful printout for debugging
X		;;
X	j)
X		appserver_only_sync=true
X	    	;;
X	n)
X		start_appserver=false
X		;;
X	w)
X		watchdog_enable=true
X		;;
X	u)
X		upgrade=true
X		echo "upgrade currently unsupported"
X		exit 8
X		;;
X	:)
X		# optional arguments are handled here
X		if [ $OPTARG = 't' ] ; then
X			rsync_throttle=""
X		else
X			echo "option '$OPTARG' requires a value" 1>&2
X			usage
X		fi
X		;;
X	t)
X		if echo $OPTARG | grep -q '^-' ; then
X			((OPTIND--))
X			OPTARG=0
X		fi
X		if [ $OPTARG -eq 0 ] ; then
X			rsync_throttle=""
X		else
X			rsync_throttle="--bwlimit=$OPTARG"
X		fi
X		;;
X	z)
X		rsync_compression="-z"
X		;;
X	c)
X		APPD_ROOT=$OPTARG
X		;;
X	a)
X		APPDMA_ROOT=$OPTARG
X		[[ -f $APPDMA_ROOT/machineagent.jar ]] || err "-a directory $APPDMA_ROOT is not a machine agent install directory"
X		;;
X	F)
X		final=true
X		;;
X	W)
X		wildcard=true
X		;;
X	D)
X		DEBUGCMD="set -vx"
X		eval $DEBUGCMD
X		;;
X	f)
X		echo "type 'confirm' to stop appserver and install HA"
X		read confirm
X		if [ "$confirm" != confirm ] ; then
X			exit 2;
X		fi
X		final=true
X		;;
X	h)
X		help
X		usage
X		;;
X	H|*)
X		if [ $flag != H ] ; then
X			echo "unknown option flag $OPTARG"
X		fi
X		usage
X		;;
X	esac
Xdone
X
Xif [ -z "$internal_vip" ] ; then
X	internal_vip=$external_vip
Xfi
X
Xeval `parse_vip external_vip $external_vip`
Xeval `parse_vip internal_vip $internal_vip`
Xeval `parse_vip controller_monitor $controller_monitor`
X
X# sanity check - verify that the appd_user and the directory owner are the same
Xif [ `ls -ld .. | awk '{print $3}'` != `id -un` ] ; then
X	echo "Controller root directory not owned by current user"
X	exit 1
Xfi
X
Xif [ "$appserver_only_sync" == "true" ] && [ "$final" == "true" ] ; then
X	echo "\
XApp-server-only and final sync modes are mutually exclusive.  Please run with
X-j or -f, not both."
X	exit 1
Xfi
X
Xrequire "ex" "vim-minimal" "vim-tiny" || exit 1
Xrequire "rsync" "rsync" "rsync" || exit 1
X
Xif [ "$debug" == "true" ] ; then
X	require "parallel" "moreutils-parallel" "parallel" || exit 1
Xfi
X
Xfunction cleanup() {
X	rm -rf $tmpdir
X}
X
Xtrap cleanup EXIT
Xcleanup
Xmkdir -p $tmpdir
X
Xfunction handle_interrupt(){
X	echo "Caught interrupt."
X	if [[ -n `jobs -p` ]] ; then
X		echo "Killing child processes."
X		kill $(jobs -p) 2>/dev/null
X	fi
X	echo "Exiting"
X	exit
X}
X
X# helper function to wrap up running, checking and possibly erroring a general shell command
Xfunction runcmd {
X	local cmd="$*"
X	if ! $cmd ; then
X		echo "\"$cmd\" command failed"
X		exit 1
X	fi
X}
X
Xtrap handle_interrupt INT
X
X#
X# set any variables dependent on command options
X#
Xrepl_log=$APPD_ROOT/logs/replicate.log
XWATCHDOG_ENABLE=$APPD_ROOT/HA/WATCHDOG_ENABLE
X#
X# if there's already a replicate log, rename the old one
X#
Xif [ -e $repl_log ] ; then
X	echo "  -- replication log renamed" `date` | tee -a $repl_log
X	mv $repl_log $repl_log.`date +%F.%T`
Xfi
X
X#
X# log versions and arguments
X#
Xecho "  -- replication log " `date` > $repl_log
Xecho -n "  -- version: " >> $repl_log 
Xgrep '$Id' $0 | head -1 >> $repl_log
Xecho "  -- command line options: " "$@" >> $repl_log
Xecho "  -- hostname: " `hostname` >> $repl_log
Xecho "  -- appd root: $APPD_ROOT" >> $repl_log
X
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $repl_log
X	usage
Xfi
X
Xif [ -z "$secondary" ] ; then
X	echo secondary hostname must be set | tee -a $repl_log
X	usage
Xfi
X
X#
X# make sure we are running as the right user
X#
XRUNUSER=`awk -F= '/^[\t ]*user=/ {print $2}' $APPD_ROOT/db/db.cnf`
Xif [ -z "$RUNUSER" ] ; then
X        echo user not set in $APPD_ROOT/db/db.cnf | tee -a $repl_log
X        exit 1
Xfi
Xif [ `id -un` != "$RUNUSER" ] ; then
X	echo replicate script must be run as $RUNUSER | tee -a $repl_log
X	exit 1
Xfi
X
Xecho "  -- appdynamics run user: $RUNUSER" | tee -a $repl_log
X
X#
X# verify no-password ssh is set up
X#
Xecho "  -- assert no password ssh" | tee -a $repl_log
Xif ! ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no $secondary true ; then
X	echo "no-password ssh not set up" | tee -a $repl_log
X	exit 4
Xfi
X
X#
X# find a compatible cipher - important for speed
X#
Xfor ssh_crypto in aes128-gcm@openssh.com aes128-ctr aes128-cbc arcfour128 3des-cbc lose ; do
X	if ssh -c $ssh_crypto $secondary true >/dev/null 2>&1 ; then
X		break;
X	fi
Xdone
Xif [ "$ssh_crypto" = "lose" ] ; then
X	echo "  -- default crypto" | tee -a $repl_log
X	rsync_crypto=
Xelse
X	echo "  -- using $ssh_crypto crypto" | tee -a $repl_log
X	rsync_crypto="--rsh=ssh -c $ssh_crypto"
Xfi
X
X#
X# make sure we aren't replicating to ourselves!
X#
Xmyhostname=`hostname`
Xthemhostname=`ssh $secondary hostname 2>/dev/null`
X
Xif [ "$myhostname" = "$themhostname" ] ; then
X	echo "  -- self-replication meaningless"
X	exit 14
Xfi
X
Xdatadir=`grep ^datadir $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xinnodb_logdir=`grep ^innodb_log_group_home_dir $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xif [ -z "$innodb_logdir" ] ; then
X	innodb_logdir="$datadir"
Xfi
X
Xif [ "$appserver_only_sync" != "true" ] ; then
X
X	#
X	# sanity check: make sure we don't have the controller.sh interlock active.
X	# if there's no controller.sh file, we are the target of an incremental!
X	echo "  -- assert non-incremental" | tee -a $repl_log
X	if ! [ -x $APPD_ROOT/bin/controller.sh ] ; then
X		echo "copying from disabled controller - BOGUS!" | tee -a $repl_log
X		exit 15
X	fi
X
X	#
X	# make sure that the primary database is up.  if not, start it
X	#
X	if echo "exit" | $APPD_ROOT/HA/mysqlclient.sh 2>&1 | grep -q "ERROR 2003" ; then
X		echo "  -- starting primary database" | tee -a $repl_log
X		$APPD_ROOT/bin/controller.sh start-db >> $repl_log 2>&1
X	fi
X
X	#
X	# make sure replication has stopped
X	#
X	echo "  -- stopping replication" | tee -a $repl_log
X	echo "STOP SLAVE;RESET SLAVE ALL;RESET MASTER;" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
X	#
X	# sanity check: make sure we are not the passive side. replicating the
X	# broken half of an HA will be a disaster!
X	echo "  -- assert active side" | tee -a $repl_log
X	if echo "select value from global_configuration where name = 'appserver.mode'" | $APPD_ROOT/bin/controller.sh login-db | grep -q passive ; then
X		echo "copying from passive controller - BOGUS!" | tee -a $repl_log
X		exit 3
X	fi
X
X	#
X	# force the ha.controller.type to primary, 
X	# this should kill the assassin if it running.
X	#
X	echo "  -- force primary" | tee -a $repl_log
X	echo "update global_configuration_local set value='primary' where name = 'ha.controller.type';" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log
X
X	#
X	# flush tables on the primary
X	# this is to force mtimes to sync up with reality on an imperfect copy
X	#
X	echo "  -- flush tables" | tee -a $repl_log
X	echo "flush tables;" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log
X
X	# stop the secondary database (and anything else)
X	# this may fail totally
X	#
X	echo "  -- stopping secondary db if present" | tee -a $repl_log
X	( stop_appdynamics_services $secondary || ssh $secondary $APPD_ROOT/bin/controller.sh stop ) >> $repl_log 2>&1
X
X	#
X	# the secondary loses controller.sh until we are ready
X	# this inhibits starting an incomplete controller
X	#
X	echo "  -- inhibit running of secondary and delete mysql/innodb logfiles" | tee -a $repl_log
X	ssh $secondary rm -f $APPD_ROOT/bin/controller.sh \
X		"$innodb_logdir/ib_logfile*"
X		"$datadir/*log*" \
X		$datadir/ibdata1 >> $repl_log 2>&1
X	
X	#
X	# disable automatic start of replication slave
X	#
X	echo "skip-slave-start=true" >> $APPD_ROOT/db/db.cnf
Xfi
X
X#
X# if final, make sure the latest init scripts are installed and stop the primary database
X#
Xif [ $final == 'true' ] ; then
X
X	# make sure the latest init scripts are installed on both hosts
X	if [ "$running_as_root" == "false" ] ; then
X		if ! verify_init_scripts; then
X			missing_init="true" 
X		fi
X		if ! verify_init_scripts $secondary ; then
X			missing_init="true"
X		fi
X		if [ "$missing_init" = "true" ] ; then
X			echo "Cannot proceed"
X			exit 7
X		fi
X		# verify that we can cause service state changes
X		if ! verify_privilege_escalation $secondary ; then
X			bad_privilege_escalation="true"
X		fi
X		if [ "$bad_privilege_escalation" = "true" ] ; then
X			echo "Cannot proceed"
X			exit 9
X		fi
X	else
X		$APPD_ROOT/HA/install-init.sh
X		ssh $secondary $APPD_ROOT/HA/install-init.sh
X	fi
X
X	echo "  -- stopping primary" | tee -a $repl_log
X	rsync_opts=$final_rsync_opts
X	rsync_throttle=""
X	( stop_appdynamics_services || $APPD_ROOT/bin/controller.sh stop ) >> $repl_log 2>&1
Xfi
X
X#
X# make sure the db.cnf is HA-enabled.  if the string ^server-id is not there,
X# then the primary has not been installed as an HA.
X#
Xecho "  -- checking HA installation" | tee -a $repl_log
Xif grep -q ^server-id $APPD_ROOT/db/db.cnf ; then
X	echo "  --   server-id present" | tee -a $repl_log
Xelse
X	echo "  --   server-id not present" | tee -a $repl_log
X	cat <<- 'ADDITIONS' >> $APPD_ROOT/db/db.cnf
X	# Replication -- MASTER MASTER (for HA installs) -- Should be appended 
X	# to the end of the db.cnf file for the PRIMARY controller.
X	binlog_cache_size=1M
X	max_binlog_cache_size=10240M
X	log_bin=bin-log
X	log_bin_index=bin-log.index 
X	relay_log=relay-log
X	relay_log_index=relay-log.index
X	innodb_support_xa=1
X	sync_binlog=0
X	log-slow-slave-statements
X	log-slave-updates
X	server-id=666  #  this needs to be unique server ID !!!
X	replicate-same-server-id=0
X	auto_increment_increment=10
X	auto_increment_offset=1
X	expire_logs_days=8
X	binlog_format=MIXED
X	replicate_ignore_table=controller.ejb__timer__tbl
X	replicate_ignore_table=controller.connection_validation
X	replicate_ignore_table=controller.global_configuration_local
X	replicate_wild_ignore_table=controller.mq%
X	replicate_wild_ignore_table=mysql.%
X	slave-skip-errors=1507,1517,1062,1032,1451
X	# added to speed up startup
X	innodb_stats_sample_pages=1
X	ADDITIONS
Xfi
X
X#
X# force server id - for failback
X#
Xex -s $APPD_ROOT/db/db.cnf <<- SETID
X/^server-id=/s,=.*,=666,
Xwq
XSETID
X
X#
X# make an empty directory on the secondary if needed
X#
Xecho "  -- mkdir if needed" | tee -a $repl_log
Xssh $secondary mkdir -p $APPD_ROOT >> $repl_log 2>&1 || err "failed to mkdir $APPD_ROOT on $secondary"
Xssh $secondary mkdir -p $datadir >> $repl_log 2>&1 || err "failed to mkdir $datadir on $secondary"
X
X#
X# do a permissive chmod on the entire destination
X#
Xecho "  -- chmod destination" | tee -a $repl_log
Xssh $secondary "find $APPD_ROOT -type f -exec chmod +wr {} +" >> $repl_log 2>&1 
X
X#
X# check date on both nodes.  rsync is sensitive to skew
X#
Xecho "  -- checking clocks" | tee -a $repl_log
Xecho -n "primary date: " >> $repl_log
Xdate >> $repl_log 2>&1 
Xecho -n "secondary date: " >> $repl_log
Xssh $secondary date >> $repl_log 2>&1 
Xrmdate=`ssh $secondary date +%s`
Xlodate=`date +%s`
Xskew=$((rmdate-lodate))
Xif [ $skew -gt 60 ] || [ $skew -lt -60 ]; then
X	echo unacceptable clock skew: $rmdate $lodate $skew
X	exit 6
Xfi
Xecho "  --   clock skew: $skew" | tee -a $repl_log
X
Xif [ "$appserver_only_sync" == "true" ] ; then
X	echo "  -- Rsync'ing controller app server only: $APPD_ROOT" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression               \
X	    --exclude=app_agent_operation_logs/\*                          \
X		--exclude=db/\*                                                \
X		--exclude=logs/\*                                              \
X		--exclude=tmp\*                                                \
X		$APPD_ROOT/ $secondary:$APPD_ROOT >> $repl_log
X		echo "  -- Rsyncs complete" | tee -a $repl_log
X		echo "  -- App server only sync done" | tee -a $repl_log
X		exit 0
Xelse
X	#
X	# clean out the old relay and bin-logs
X	#
X	echo "  -- Removing old replication logs" | tee -a $repl_log
X	rm -f $datadir/bin-log* $datadir/relay-log* $datadir/master.info | tee -a $repl_log 2>&1
X	ssh $secondary "find $datadir -print | grep bin-log | xargs rm  -f" | tee -a $repl_log 2>&1
X	ssh $secondary "find $datadir -print | grep relay-log | xargs rm  -f" | tee -a $repl_log 2>&1
X	ssh $secondary rm -f $datadir/master.info | tee -a $repl_log 2>&1
X
X	#
X	# maximum paranoia:  build space ID maps of each of the innodb data files and prune differences
X	# caution: gnarly quoting
X	#
X	echo "  -- Building innodb file maps" | tee -a $repl_log
X	rm -f $tmpdir/ibdlist.local $tmpdir/ibdlist.remote
X	find $datadir/controller \
X		-name \*.ibd \
X		-exec sh -c 'echo -n "{} " ; od -N 150 -t x4 -A none {} | md5sum' \; | \
X		sort > $tmpdir/ibdlist.local
X
X	ssh $secondary "find $datadir/controller -name \*.ibd -exec sh -c 'echo -n \"{} \" ; od -N 150 -t x4 -A none {} | md5sum' \;" | sort > $tmpdir/ibdlist.remote
X
X	diff $tmpdir/ibdlist.local $tmpdir/ibdlist.remote | awk '/^>/ {print $2}' > $tmpdir/worklist
X	
X	discrepancies=`wc -w $tmpdir/worklist | awk '{print $1}'`
X	if [ $discrepancies -gt 0 ] ; then
X		printf "  --   found %d discrepancies\n" $discrepancies | tee -a $repl_log
X		cat $tmpdir/worklist | tee -a $repl_log
X		scp $tmpdir/worklist $secondary:/tmp/replicate-prune-worklist
X		ssh $secondary "cat /tmp/replicate-prune-worklist | xargs rm -f"
X	fi
X
X	#
X	# copy the controller + data to the secondary
X	#
X	echo "  -- Rsync'ing Controller: $APPD_ROOT" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression                \
X	    --exclude=bin/controller.sh					                    \
X	    --exclude=license.lic						                    \
X		--exclude=logs/\*							                    \
X		--exclude=db/data/\*                                            \
X		--exclude=db/bin/.status                                        \
X		--exclude=app_agent_operation_logs/\*                           \
X		--exclude=appserver/glassfish/domains/domain1/appagent/logs/\*  \
X		--exclude=tmp/\*                                                \
X		$APPD_ROOT/ $secondary:$APPD_ROOT >> $repl_log
X	echo "  -- Rsync'ing Data: $datadir" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression                \
X	    --exclude=bin-log\*						                        \
X	    --exclude=relay-log\*					                        \
X	    --exclude=\*.log						                        \
X	    --exclude=master.info                                           \
X	    --exclude=\*.pid                                                \
X	    --exclude=ib_logfile\*                                          \
X	    $datadir/ $secondary:$datadir >> $repl_log
X	echo "  -- Rsyncs complete" | tee -a $repl_log
Xfi
X
Xif [ "$final" == "true" ] ; then
X
X	if [ "$running_as_root" == "true" ] ; then
X		ssh $secondary $APPD_ROOT/HA/install-init.sh
X	fi
X
X	#
X	# make sure the machine agent, if installed, reports to the internal vip
X	# since we don't know where the machine agent is, look in a few likely places
X	#
X	for mif in $APPD_ROOT/MachineAgent/conf/controller-info.xml \
X			$APPD_ROOT/../MachineAgent/conf/controller-info.xml ; do
X		if [ -f $APPD_ROOT/MachineAgent/conf/controller-info.xml ] ; then
X			if [ -f "$mif" ] ; then
X				ex -s $mif <<- SETMACHINE
X					%s/\(<controller-host>\)[^<]*/\1$internal_vip_host/
X					%s/\(<controller-port>\)[^<]*/\1$internal_vip_port/
X					wq
X				SETMACHINE
X			fi
X		fi
X	done
Xfi
X
X#
X# always update the changeid - this marks the secondary
X#
Xcat > $tmpdir/ha.changeid <<- 'CHANGEID'
X/^server-id=/s,666,555,
Xwq
XCHANGEID
X
X#
X# edit the secondary to change the server id
X#
Xecho "  -- changing secondary server id" | tee -a $repl_log
Xcat $tmpdir/ha.changeid | ssh $secondary ex -s $APPD_ROOT/db/db.cnf >> $repl_log 2>&1
X
X#
X# if we're only do incremental, then no need to stop primary
X#
Xif [ $final == 'false' ] ; then
X	#
X	# validate init scripts and sudo config
X	# and warn user if they need to be updated before final
X	#
X	if [ "$running_as_root" == 'false' ] ; then
X		errors=0
X		verify_init_scripts || ((errors++))
X		verify_init_scripts $secondary || ((errors++))
X		if [ $errors -lt 1 ] ; then
X			verify_privilege_escalation $secondary
X		fi
X	fi
X	echo "  -- incremental sync done" | tee -a $repl_log
X	exit 0
Xfi
X
X#
X# plug the external hostname, protocol and port into the domain.xml
X#
Xif [ -n "$external_vip" ] ; then
X	echo "  -- edit domain.xml to point at external host" | tee -a $repl_log
X	if [ "$internal_vip_protocol" == "https" ] ; then
X		if grep -q appdynamics.controller.ssl.enabled $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml ; then
X			ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- SETHTTPS
X				%s/\(-Dappdynamics.controller.ssl.enabled=\)[^<]*/\1true/
X				wq
X			SETHTTPS
X		else
X			ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- ADDHTTPS
X				/-Dappdynamics.controller.hostName/a
X				<jvm-options>-Dappdynamics.controller.ssl.enabled=true</jvm-options>
X				.
X				wq
X			ADDHTTPS
X		fi
X	fi
X	ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- SETHOST
X		%s/\(-Dappdynamics.controller.hostName=\)[^<]*/\1$internal_vip_host/
X		%s/\(-Dappdynamics.controller.port=\)[^<]*/\1$internal_vip_port/
X		%s/\(-Dappdynamics.controller.services.hostName=\)[^<]*/\1$internal_vip_host/
X		%s/\(-Dappdynamics.controller.services.port=\)[^<]*/\1$internal_vip_port/
X		%s,\(-Dappdynamics.controller.ui.deeplink.url=\)[^<]*,\1$external_vip_protocol://$external_vip_host:$external_vip_port,
X		wq
X	SETHOST
Xfi
X
X#
X# Check if controllers should send their internal App Agent metrics to a specified monitor controller...
X# 
X# NOTE: 
X# 1. '-e' or '-i' VIP options may or may not have been supplied
X# 2. This specified monitor controller can be local or remote. 
X# 3. If no -e or -i options have been specified then ASSUME that only replication is needed
X#    and that a failure of the primary will be followed by a replicate from secondary back
X#    over the top of the primary. This is why controller app agent is configured to primary.
X#
Xif [[ -n "$controller_monitor_args" ]] ; then
X	echo "  -- edit domain.xml to point app agent at custom controller" | tee -a $repl_log
X
X	ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- EOT
X		%s/\(-Dappdynamics.controller.hostName\)[^<]*/\1=$controller_monitor_host/
X		%s/\(-Dappdynamics.controller.port\)[^<]*/\1=$controller_monitor_port/
X		wq
X	EOT
X
X	# following properties may not yet exist in domain.xml
X	ssl_enabled=false
X        if [ "$controller_monitor_protocol" == "https" ] ; then
X		ssl_enabled=true
X	fi
X	upsert "-Dappdynamics.controller.ssl.enabled"	"$ssl_enabled"
X	upsert "-Dappdynamics.agent.accountName"	"${cmargs['account_name']}"
X	upsert "-Dappdynamics.agent.accountAccessKey"	"${cmargs['access_key']}"
X	upsert "-Dappdynamics.agent.applicationName"	"${cmargs['app_name']}"
X	unset ssl_enabled
Xfi
X
X#
X# send the edited domain.xml
X#
Xecho "  -- copy domain.xml to secondary" | tee -a $repl_log
Xscp -p $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml $secondary:$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml >> $repl_log 2>&1
X
X#
X# write the primary hostname into the node-name property
X#
Xecho "  -- setting up controller agent on primary" | tee -a $repl_log
Xfor ci in $APPD_ROOT/appserver/glassfish/domains/domain1/appagent/conf/controller-info.xml \
X	$APPD_ROOT/appserver/glassfish/domains/domain1/appagent/ver*/conf/controller-info.xml ; do
X	ex -s $ci <<- SETNODE1
X		%s/\(<node-name>\)[^<]*/\1$primary/
X		wq
X	SETNODE1
Xdone
X
X#
X# write the secondary hostname into the node-name property
X#
Xecho "  -- setting up controller agent on secondary" | tee -a $repl_log
Xfor ci in $APPD_ROOT/appserver/glassfish/domains/domain1/appagent/conf/controller-info.xml \
X	$APPD_ROOT/appserver/glassfish/domains/domain1/appagent/ver*/conf/controller-info.xml ; do
X	ssh $secondary ex -s $ci <<- SETNODE2
X		%s/\(<node-name>\)[^<]*/\1$secondary/
X		wq
X	SETNODE2
Xdone
X
Xif [ "$debug" = "true" ] ; then
X	echo "  -- building file lists" | tee -a $repl_log
X	ls -1 $datadir/controller/* | parallel md5sum | sort -k 2 --buffer-size=10M > $APPD_ROOT/logs/filelist.primary &
X	ssh $secondary 'ls -1 '$datadir'/controller/* | parallel md5sum' | sort -k 2 --buffer-size=10M > $APPD_ROOT/logs/filelist.secondary &
X	wait
Xfi
X
X#
X# restart the primary db
X#
Xecho "  -- starting primary database" | tee -a $repl_log
X# Do not proceed unless the primary starts cleanly or we could end up with
X#  unexpected failovers.
Xif ! service appdcontroller-db start >> $repl_log 2>&1 ; then
X	echo "-- failed to start primary database.  Exiting..." | tee -a $repl_log
X	exit 1
Xfi
X
X# Any existing machine agents also need to be told where to report
X# Only able to reconfig machine agent if 
X# 	1) installed in *same* directory on both servers 
X#	2) writeable conf/controller-info.xml on both servers
X#	3) install-init.sh has successfully run on both servers as root
X# This is the default if installed with Linux rpm on both servers.
X#
X# Rules for deciding where Machine Agent should report to are:
X#  - If a controller monitor has been defined then send primary/secondary MA data there
X#  - Else if a VIP/Load-balancer has been defined then send primary/secondary MA data there
X#  - Else send primary/secondary MA data to primary (secondary for backup only)
X#
Xif [[ -n "$APPDMA_ROOT" ]] ; then
X	# check if install-init.sh or RPM has installed the appdynamics-machine-agent service
X	if ! check_installed_service appdynamics-machine-agent; then
X		err "appdynamics-machine-agent service has not been installed on $primary.
XPlease run \"$APPD_ROOT/HA/install-init.sh <$(get_privilege_escalation) option> -a $APPDMA_ROOT\"
Xas root on $primary before proceeding."
X	fi
X	if ! remote_check_installed_service $secondary appdynamics-machine-agent; then
X		err "appdynamics-machine-agent service has not been installed on $secondary.
XPlease run \"$APPD_ROOT/HA/install-init.sh <$(get_privilege_escalation) option> -a $APPDMA_ROOT\"
Xas root on $secondary before proceeding."
X	fi
X
X	ma_host=""
X	ma_port=""
X	ma_account_name=""
X	ma_access_key=""
X	ma_ssl_enabled=false
X	ma_application_name=""
X	ma_tier_name="App Server"
X	ma_node_name="$primary"
X	label=
X	if [[ -n "$controller_monitor_args" ]] ; then	# need to report to monitor controller
X		# all needed values nicely supplied to -m cmd line arg
X		ma_host=$controller_monitor_host
X		ma_port=$controller_monitor_port
X		ma_account_name=${cmargs['account_name']}
X		ma_access_key=${cmargs['access_key']}
X        	if [[ "$controller_monitor_protocol" == "https" ]] ; then
X			ma_ssl_enabled=true
X		fi
X		ma_application_name="${cmargs['app_name']}"
X		label="custom controller"
X	elif [[ -n "$internal_vip" ]] ; then		# use load balancer
X		# assume primary MySQL's access_key will be replicated
X		ma_host=$internal_vip_host
X		ma_port=$internal_vip_port
X		ma_account_name="system"
X		ma_access_key=$(echo "select access_key from account where id=1 and name='system'\G" | \
X			$APPD_ROOT/HA/mysqlclient.sh | awk -F: '/^access/ {gsub(/ /,"", $2); print $2}')
X		if [[ -z "$ma_access_key" ]]; then
X			echo "failed to get $primary access_key for machine agent config" | tee -a $repl_log
X		fi
X        	if [[ "$internal_vip_protocol" == "https" ]] ; then
X			ma_ssl_enabled=true
X		fi
X		ma_application_name="AppDynamics Controller"
X		label="load balancer"
X	else						# user just wants to set up replication alone
X		DOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X		ma_host=$primary
X		ma_port=$(awk -F'=' 'tolower($0) ~ /appdynamics.controller.port/ {sub(/<.*$/,"",$2);print $2}' $DOMAIN_XML)
X		if [[ -z "$ma_port" ]] ; then
X			echo "failed to get $primary appdynamics.controller.port value for machine agent config" | tee -a $repl_log
X		fi
X		ma_account_name="system"
X		ma_access_key=$(echo "select access_key from account where id=1 and name='system'\G" | \
X			$APPD_ROOT/HA/mysqlclient.sh | awk -F: '/^access/ {gsub(/ /,"", $2); print $2}')
X		if [[ -z "$ma_access_key" ]]; then
X			echo "failed to get $primary access_key for machine agent local config" | tee -a $repl_log
X		fi
X		ma_ssl_enabled=$(awk -F= 'tolower($0) ~ /appdynamics.controller.ssl.enabled/ {sub(/<.*$/,"",$2);print $2}' $DOMAIN_XML)
X		[[ -z "$ma_ssl_enabled" ]] && ma_ssl_enabled=false
X		unset DOMAIN_XML
X		ma_application_name="AppDynamics Controller"
X		label="primary controller"
X	fi
X
X	MA_CFG=$APPDMA_ROOT/conf/controller-info.xml
X	if [[ -w "$MA_CFG" ]] ; then
X		echo "  -- edit primary machine agent to point at $label" | tee -a $repl_log
X		ex -s $MA_CFG <<- SETMACHINE
X			%s/\(<controller-host>\)[^<]*/\1$ma_host/
X			%s/\(<controller-port>\)[^<]*/\1$ma_port/
X			%s/\(<account-name>\)[^<]*/\1$ma_account_name/
X			%s/\(<account-access-key>\)[^<]*/\1$ma_access_key/
X			%s/\(<controller-ssl-enabled>\)[^<]*/\1$ma_ssl_enabled/
X			%s/\(<application-name>\)[^<]*/\1$ma_application_name/
X			%s/\(<tier-name>\)[^<]*/\1$ma_tier_name/
X			%s/\(<node-name>\)[^<]*/\1$ma_node_name/
X			wq
X		SETMACHINE
X		service appdynamics-machine-agent stop >> $repl_log 2>&1
X		if service appdynamics-machine-agent start >> $repl_log 2>&1; then
X			echo "  -- restarted primary machine agent" | tee -a $repl_log
X		else
X				echo "failed to start primary machine agent" | tee -a $repl_log
X		fi
X	else
X		echo "failed to configure primary machine agent" | tee -a $repl_log
X	fi
X	# update secondary server if it has a machine agent in exactly same directory
X	if ssh $secondary "bash -c '[[ -w $MA_CFG ]]'" ; then
X		echo "  -- edit secondary machine agent to point at $label" | tee -a $repl_log
X		sed -e "s/\(<node-name>\)[^<]*/\1$secondary/" < $MA_CFG > $tmpdir/ma_cfg.secondary
X	   	if scp $tmpdir/ma_cfg.secondary $secondary:$MA_CFG ; then
X			remservice -t $secondary appdynamics-machine-agent stop >> $repl_log 2>&1
X			if remservice -t $secondary appdynamics-machine-agent start >> $repl_log 2>&1; then
X				echo "  -- restarted secondary machine agent" | tee -a $repl_log
X			else
X				echo "failed to start secondary machine agent" | tee -a $repl_log
X		  	fi
X		else
X			echo "failed to copy config to secondary machine agent ($MA_CFG)" | tee -a $repl_log
X		fi
X	else
X		echo "failed to configure primary machine agent" | tee -a $repl_log
X	fi
X	unset MA_CFG
X	unset ma_host ma_port ma_account_name ma_access_key ma_ssl_enabled ma_application_name ma_tier_name ma_node_name label
Xfi
X
Xif [ -z $wildcard ] ; then
X	#
X	# let's probe the canonical hostnames from the local database
X	#
X	echo "  -- canonicalize hostnames" | tee -a $repl_log
X	primary1=`$APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | awk '
X		/ERROR 1045/ { gsub("^.*@",""); print $1;}
X		/ERROR 1130/ { gsub("^.*Host ",""); print $1;}' | tr -d \'`
X
X	secondary1=`ssh $secondary $APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | awk '
X		/ERROR 1045/ { gsub("^.*@",""); print $1;}
X		/ERROR 1130/ { gsub("^.*Host ",""); print $1;}' | tr -d \'`
X
X	#
X	# print the canonical hostnames
X	#
X	if [ "$primary1" = 'ERROR' -o "$secondary1" = 'ERROR' -o -z "$primary1" -o -z "$secondary1" ] ; then
X		echo "cannot establish communications between mysql instances" | tee -a $repl_log
X		echo "check firewall rules" | tee -a $repl_log
X		echo "primary: $primary1" | tee -a $repl_log
X		echo "secondary: $secondary1" | tee -a $repl_log
X		$APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | tee -a $repl_log
X		ssh $secondary $APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | tee -a $repl_log
X		exit 5
X	fi
X
X	[[ $primary1 != localhost ]] && primary=$primary1	# avoid issues with 127.0.0.1 having been set to hostname in /etc/hosts
X	[[ $secondary1 != localhost ]] && secondary=$secondary1	# avoid issues with 127.0.0.1 having been set to hostname in /etc/hosts
X	grant_primary=$primary
X	grant_secondary=$secondary
Xelse
X	grant_primary='%'
X	grant_secondary='%'
Xfi
X
Xecho "  -- primary: $primary" | tee -a $repl_log
Xecho "  -- secondary: $secondary" | tee -a $repl_log
X
X#
X# build the scripts
X#
X
Xcat >$tmpdir/ha.primary <<- PRIMARY
XSTOP SLAVE;
XRESET SLAVE ALL;
XRESET MASTER;
XGRANT ALL ON *.* TO 'controller_repl'@'$grant_secondary' IDENTIFIED BY 'controller_repl';
XFLUSH HOSTS;
XCHANGE MASTER TO MASTER_HOST='$secondary', MASTER_USER='controller_repl', MASTER_PASSWORD='controller_repl', MASTER_PORT=$dbport;
Xupdate global_configuration_local set value = 'active' where name = 'appserver.mode';
Xupdate global_configuration_local set value = 'primary' where name = 'ha.controller.type';
Xtruncate ejb__timer__tbl;
XPRIMARY
X
Xcat > $tmpdir/ha.secondary <<- SECONDARY
XSTOP SLAVE;
XRESET SLAVE ALL;
XRESET MASTER;
XGRANT ALL ON *.* TO 'controller_repl'@'$grant_primary' IDENTIFIED BY 'controller_repl'; FLUSH HOSTS;
XCHANGE MASTER TO MASTER_HOST='$primary', MASTER_USER='controller_repl', MASTER_PASSWORD='controller_repl', MASTER_PORT=$dbport;
Xupdate global_configuration_local set value = 'passive' where name = 'appserver.mode';
Xupdate global_configuration_local set value = 'secondary' where name = 'ha.controller.type';
Xtruncate ejb__timer__tbl;
XSECONDARY
X
Xcat > $tmpdir/ha.enable <<- 'DISABLE'
Xg/^skip-slave-start/d
Xwq
XDISABLE
X
X#
X# make all the changes on the primary to force master
X#
Xecho "  -- setting up primary slave" | tee -a $repl_log
Xcat $tmpdir/ha.primary | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
X#
X# now we need a secondary controller.sh
X#
Xecho "  -- copy controller.sh to secondary" | tee -a $repl_log
Xscp -p $APPD_ROOT/bin/controller.sh $secondary:$APPD_ROOT/bin >> $repl_log 2>&1
X
X#
X# but disable the appserver
X#
Xecho "  -- disable secondary appserver" | tee -a $repl_log
Xssh $secondary touch $APPD_ROOT/HA/APPSERVER_DISABLE >> $repl_log 2>&1
X
X#
X# make sure the master.info is not going to start replication yet, since it will be
X# a stale log position
X#
Xecho "  -- remove master.info" | tee -a $repl_log
Xssh $secondary rm -f $datadir/master.info >> $repl_log 2>&1
X
X#
X# start the secondary database
X#
Xecho "  -- start secondary database" | tee -a $repl_log
Xif ! remservice -t $secondary appdcontroller-db start >> $repl_log 2>&1 ; then
X	echo "could not start secondary database"
X	exit 10
Xfi
X
X#
X# ugly hack here - there seems to be a small timing problem
X#
Xecho "  -- wait for secondary to start" | tee -a $repl_log
Xuntil echo "show databases" | ssh $secondary $APPD_ROOT/HA/mysqlclient.sh | grep -q "information_schema" ; do
X	echo `date` "waiting for mysql to start using $secondary" | tee -a $repl_log
X	sleep 2
Xdone
X
X#
X# make all the changes on the secondary
X#
Xecho "  -- setting up secondary slave" | tee -a $repl_log
Xcat $tmpdir/ha.secondary | ssh $secondary $APPD_ROOT/HA/mysqlclient.sh >> $repl_log 2>&1
X
Xecho "  -- removing skip-slave-start from primary" | tee -a $repl_log
Xcat $tmpdir/ha.enable | ex -s $APPD_ROOT/db/db.cnf
Xecho "  -- removing skip-slave-start from secondary" | tee -a $repl_log
Xcat $tmpdir/ha.enable | ssh $secondary ex -s $APPD_ROOT/db/db.cnf
X
X#
X# start the replication slaves
X#
Xecho "  -- start primary slave" | tee -a $repl_log
Xecho "START SLAVE;" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
Xecho "  -- start secondary slave" | tee -a $repl_log
Xecho "START SLAVE;" | ssh $secondary $APPD_ROOT/HA/mysqlclient.sh >> $repl_log 2>&1
X
X#
X# slave status on both ends
X#
Xecho "  -- primary slave status " | tee -a $repl_log
Xecho "SHOW SLAVE STATUS\G" | \
X	$APPD_ROOT/HA/mysqlclient.sh | \
X	awk '/Slave_IO_State/ {print}
X	/Seconds_Behind_Master/ {print} 
X	/Master_Server_Id/ {print}
X	/Master_Host/ {print}' | \
X	tee -a $repl_log 2>&1
Xecho "  -- secondary slave status " | tee -a $repl_log
Xecho "SHOW SLAVE STATUS\G" | \
X	ssh $secondary $APPD_ROOT/HA/mysqlclient.sh | \
X	awk '/Slave_IO_State/ {print}
X	/Seconds_Behind_Master/ {print} 
X	/Master_Server_Id/ {print}
X	/Master_Host/ {print}' | \
X	tee -a $repl_log
X
X#
X# enable the watchdog, or not.
X#
Xif [ $watchdog_enable = "true" ] ; then
X	touch $WATCHDOG_ENABLE
X	ssh $secondary touch $WATCHDOG_ENABLE
Xelse
X	rm -f $WATCHDOG_ENABLE
X	ssh $secondary rm -f $WATCHDOG_ENABLE
Xfi
X
X#
X# handle license files - compare creation times, and use latest one
X# grab the one over there if newer
X#
Xremote_lic=0
Xlocal_lic=0
Xif ssh $secondary test -f $APPD_ROOT/license.lic ; then
X	remote_lic=`ssh $secondary grep creationDate $APPD_ROOT/license.lic | \
X		 awk -F= '{print $2}'`
Xfi
Xif [ -f $APPD_ROOT/license.lic.$secondary ] ; then
X	local_lic=`grep creationDate $APPD_ROOT/license.lic.$secondary | \
X		awk -F= '{print $2}'`
Xfi
X
Xif [ $local_lic -lt $remote_lic ] ; then
X	echo "  -- copying license file from secondary" | tee -a $repl_log
X	scp $secondary:$APPD_ROOT/license.lic $APPD_ROOT/license.lic.$secondary 
Xelif [ $local_lic -ne 0 ] ; then
X	echo "  -- copying license file to  secondary" | tee -a $repl_log
X	scp $APPD_ROOT/license.lic.$secondary $secondary:$APPD_ROOT/license.lic
Xelse
X	echo "  -- secondary license file required" | tee -a $repl_log
Xfi
X
X#
X# handle odd case - license.lic.$primary is newer
X#
Xcopy_lic=0
Xlic=0
Xif [ -f $APPD_ROOT/license.lic ] ; then
X	lic=`grep creationDate $APPD_ROOT/license.lic | awk -F= '{print $2}'`
Xfi
Xif [ -f $APPD_ROOT/license.lic.$primary ] ; then
X	copy_lic=`grep creationDate $APPD_ROOT/license.lic.$primary | \
X		awk -F= '{print $2}'`
Xfi
X
Xif [ $lic -lt $copy_lic ] ; then
X	echo "  -- using newer $license.lic.$primary" | tee -a $repl_log
X	cp $APPD_ROOT/license.lic.$primary $APPD_ROOT/license.lic
Xelif [ $lic -ne 0 ] ; then
X	echo "  -- saving license to $license.lic.$primary" | tee -a $repl_log
X	cp $APPD_ROOT/license.lic $APPD_ROOT/license.lic.$primary
Xelse
X	echo "  -- no primary license file" | tee -a $repl_log
Xfi
X
Xecho "  -- sending primary license file" | tee -a $repl_log
Xscp $APPD_ROOT/license.lic.$primary $secondary:$APPD_ROOT
X
X#
X# now enable the secondary appserver
X#
Xecho "  -- enable secondary appserver" | tee -a $repl_log
Xssh $secondary rm -f $APPD_ROOT/HA/APPSERVER_DISABLE >> $repl_log 2>&1
X
X#
X# make sure host keys are properly set to prevent ssh from hanging
X#
Xecho "  -- checking for ssh access issues" | tee -a $repl_log
Xeval `echo "show slave status\G" | $APPD_ROOT/HA/mysqlclient.sh |
X	awk 'BEGIN {OFS=""} /Master_Host/ {print "sechost=",$2}'`
Xeval `echo "show slave status\G" | ssh $secondary $APPD_ROOT/HA/mysqlclient.sh |
X	awk 'BEGIN {OFS=""} /Master_Host/ {print "prihost=",$2}'`
Xruncmd ssh -o StrictHostKeyChecking=no $sechost ssh -o StrictHostKeyChecking=no $prihost /bin/true
X
X#
X# restart the appserver
X#
Xif [ $start_appserver = "true" ] ; then
X	echo "  -- start primary appserver" | tee -a $repl_log
X	if ! service appdcontroller start >> $repl_log 2>&1 ; then
X		echo "could not start primary appdcontroller service"
X		exit 12
X	fi
X
X	echo "  -- secondary service start" | tee -a $repl_log
X	# issues with the command actually starting the watchdog on the secondary.
X	# further troubleshooting needed
X	if ! remservice -t $secondary appdcontroller start >> $repl_log 2>&1; then
X		echo "could not start secondary appdcontroller service"
X		exit 11
X	fi
X	echo "  -- HA setup complete." | tee -a $repl_log
Xfi
X
END-of-replicate.sh
echo x - install-init.sh
sed 's/^X//' >install-init.sh << 'END-of-install-init.sh'
X#!/bin/bash
X#
X# $Id: install-init.sh 2.13 2016-05-25 18:34:51 rob.navarro $
X#
X# install init script
X#
XPBRUN=`grep PBRUN= appdservice-pbrun.sh | awk -F= '{print $2}'`
X
Xfunction usage {
X	echo "$0 [-options] where:"
X	echo "   -c  # use setuid c wrapper"
X	echo "   -s  # use sudo"
X	echo "   -p  # use pbrun wrapper"
X	echo "   -x  # use user privilege wrapper"
X	echo "   -a  <Machine Agent install directory>"
X	exit 1
X}
X
Xcd $(dirname $0)
XAPPD_ROOT=`cd .. ; pwd -P`			# ignore sym links
Xif ! [ -d $APPD_ROOT/bin ] ; then
X	APPD_ROOT=/opt/AppDynamics/Controller
X	echo using default path $APPD_ROOT
Xfi
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X	#shldignore		# stop Makefile trying to embed the next source file
X	. $FUNCLIB
Xelse
X	echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X	exit 1
Xfi
X
X# ensure the functions have automated access to MySQL root passwd
Xcheck_for_mysql_passwd $APPD_ROOT || exit 1
X
X# At some point at least by 4.1.5.1 and through 4.2.0.2 the Machine agent startup process 
X# regressed. CORE-64433. This bug prevents ssh from start/stop of remote service.
Xfunction patch_broken_MA_startup {
X	local startup=$MA_install_dir/bin/machine-agent
X
X	[[ -f $startup ]] || return
X	if grep -q -- 'exec \".*jar <&- &$' $startup; then	# CORE-64433 present
X		ex -s $startup <<- EOT
X			%s,exec \(\".*jar\).*$,nohup \1 >> \$MACHINE_AGENT_HOME/logs/machine-agent.log \&,
X			wq
X		EOT
X	fi
X}
X
Xuse_pbrun=0
Xuse_cwrapper=0
Xuse_sudo=0
Xuse_root=0
Xuse_xuser=0
X
Xwhile getopts ":csprxa:" flag; do
X	case $flag in
X	x)
X		use_xuser=1
X		;;
X	c)
X		use_cwrapper=1
X		;;
X	s)
X		use_sudo=1
X		;;
X	p)
X		if [ -x $PBRUN ] ; then
X			use_pbrun=1
X		else
X			echo $PBRUN not found
X			exit 1
X		fi
X		;;
X	a)	
X		MA_install_dir=$OPTARG
X		[[ -f $MA_install_dir/machineagent.jar ]] || err "-a directory $MA_install_dir is not a machine agent install directory"
X		;;
X	:)	
X		echo "option '$OPTARG' requires a value" 1>&2
X		usage
X		;;
X	*)
X		usage
X		;;
X	esac
Xdone
X
Xif [ `id -u` != 0 ] ; then
X	echo $0 must be run as root
X	exit 0
Xfi
X
XSCRIPTNAME=$(basename $(readlink -e $0))
X
Xexport PATH=/sbin:/usr/sbin:$PATH
X
X# list of AppDynamics services in start order
XAPPDYNAMICS_SERVICE_LIST=( appdcontroller-db appdcontroller )
X# include Machine agent service name if specified on command line
X[[ -n "$MA_install_dir" ]] && APPDYNAMICS_SERVICE_LIST=( ${APPDYNAMICS_SERVICE_LIST[*]} appdynamics-machine-agent )
X
XVENDOR=`lsb_release -i 2>/dev/null | awk '{print $3}'`
X
Xif echo $VENDOR | grep -iq ubuntu ; then
X	#
X	# Define explicit start and stop order lists for Ubuntu and other distros
X	# were update-rc.d ignores the LSB dependency headers
X	#
X	APPDYNAMICS_SERVICE_START=( 90 91 92 )
X	APPDYNAMICS_SERVICE_STOP=( 90 89 08 )
Xfi
X
XAPPDSERVICE=/sbin/appdservice
X
XROOTOWNER=`ls -ld $APPD_ROOT | awk '{print $3}'`
XRUNUSER=`su -s /bin/bash -c "awk -F= '/^[\t ]*user=/ {print \\$2}' $APPD_ROOT/db/db.cnf" $ROOTOWNER`
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X	if [ `expr $use_cwrapper + $use_sudo + $use_pbrun + $use_xuser` == 0 ] ; then
X		echo non-root usage requires at least one privilege escalation method
X		usage
X	fi
X	if [ `expr $use_cwrapper + $use_pbrun + $use_xuser` -gt 1 ] ; then
X		echo cwrapper, xuser and pbrun are mutually exclusive
X		usage
X	fi
Xelse
X	use_root=1
Xfi
X
XCHKCONFIG=`which chkconfig 2>/dev/null`
XUPDATE_RC_D=`which update-rc.d 2>/dev/null`
XSERVICE=`which service 2>/dev/null`
X
Xfunction require() {
X	# args: executable "redhat package" "debian package" [ force|advise ] ["<reason package is required>"]
X	local errors=0
X	if ! [[  -x `which $1 2>/dev/null` ]] || [ "$4" == "force" ] ; then
X		if [[ -x `which apt-get 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $3 not installed."
X				echo "$3 is required $5"
X				return 1
X			else
X				if ! apt-get -qq -y install $3 && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		elif [[ -x `which yum 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $2 not installed."
X				echo "$2 is required $5"
X				return 1
X			else
X				if ! yum --quiet -y install $2 >/dev/null && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		fi
X		if ! [[  -x `which $1 2>/dev/null` ]] || [ "$errors" -gt 0 ] ; then
X			echo "Unable to install package containing $1"
X			return 1
X		fi
X	fi
X}
X
Xfunction install_init() {
X	# avoid messing up RPM, skip service install step if RPM installed
X	if rpm -qi --quiet $1 2>/dev/null; then 
X	   	mkdir $MA_install_dir/logs &> /dev/null
X		patch_broken_MA_startup
X		return
X	fi
X
X	# if dealing with the Machine Agent service...
X	if [[ -n $MA_install_dir && -f ./$1.sysconfig ]] ; then
X	   if [[ -d $MA_install_dir/jre ]] ; then		# recent MA
X	      EXTN=""
X	      patch_broken_MA_startup				# allow ssh service start/stop
X	   else							# 3.9 MA
X	      EXTN=".old"					# pick up older configs
X	   fi
X	   mkdir $MA_install_dir/logs &> /dev/null
X	   chmod 666 $MA_install_dir/conf/controller-info.xml	# allow config via replicate.sh
X	fi
X
X	echo "installing /etc/init.d/$1"
X	convert_init_script ./$1${EXTN}.sh > /etc/init.d/$1	# library function
X	chmod 0755 /etc/init.d/$1
X
X	if [ -x "$CHKCONFIG" ] ; then
X		if [[ -f ./$1${EXTN}.sysconfig ]] ; then
X			sed < ./$1${EXTN}.sysconfig > /etc/sysconfig/$1 \
X				-e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X				-e "/^MACHINE_AGENT_HOME=/s,=.*,=$MA_install_dir," \
X				-e "/\$MACHINE_AGENT_HOME/s,,$MA_install_dir,"
X			chmod 644 /etc/sysconfig/$1
X		fi
X
X		chkconfig --add $1
X	elif [ -x "$UPDATE_RC_D" ] ; then
X		if [[ -f ./$1${EXTN}.sysconfig ]] ; then
X			sed < ./$1${EXTN}.sysconfig > /etc/default/$1 \
X				-e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X				-e "/^MACHINE_AGENT_HOME=/s,=.*,=$MA_install_dir," \
X				-e "/\$MACHINE_AGENT_HOME/s,,$MA_install_dir,"
X			chmod 644 /etc/default/$1
X		fi
X
X		update-rc.d -f $1 remove 
X		update-rc.d $1 defaults $2 $3
X	else
X		echo "unsupported linux distribution: chkconfig or update-rc.d required"
X		exit 1
X	fi
X}
X
X#
X# make sure we have xmllint, bc, and the right version of ping installed
X#
Xmissing_dependencies=0
Xrequire xmllint libxml2 libxml2-utils || ((missing_dependencies++))
Xrequire bc bc bc || ((missing_dependecies++))
Xrequire ex vim-minimal vim-tiny || ((missing_dependecies++))
Xrequire curl curl curl || ((missing_dependencies++))
Xif ! ping -q -W 1 -c 1 localhost >/dev/null ; then
X	require ping iputils iputils-ping force || ((missing_dependencies++))
Xfi
Xif [ "$missing_dependencies" -gt 0 ] ; then
X	exit 1
Xfi
X
X#
X# since our RUNUSER isn't root, we want to make it so that sudo works
X# for our selected commands.   
X# this is not a security hole, it is a controlled privilege escalation, really.
X#
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X
X	if [ $use_sudo == 1 ] ; then
X		# Clean up C / pbrun wrappers if they were previously installed
X		rm -f $APPDSERVICE 2>/dev/null
X		require sudo sudo sudo || exit 1
X		[ -d /etc/sudoers.d ] || mkdir /etc/sudoers.d && chmod 0750 /etc/sudoers.d
X		grep -Eq "^#includedir[\t ]+/etc/sudoers.d[\t ]*$" /etc/sudoers || \
X		grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers || \
X		echo "#include /etc/sudoers.d/appdynamics" >> /etc/sudoers
X		if [ -x "$CHKCONFIG" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST $COMMA \\
X				$SERVICE $s *, \\
X				$CHKCONFIG $s on, \\
X				$CHKCONFIG $s off"
X				COMMA=","
X			done
X		elif [ -x "$UPDATE_RC_D" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST$COMMA \\
X				$SERVICE $s *, \\
X				$UPDATE_RC_D $s enable, \\
X				$UPDATE_RC_D $s disable"
X				COMMA=","
X			done
X		fi
X		cat > /etc/sudoers.d/appdynamics <<- SUDOERS
X		# allow appdynamics user to:
X		#    start, stop, and query status of appdynamics via init scripts
X		#    to enable and disable those init scripts
X		Defaults:$RUNUSER !requiretty
X		Cmnd_Alias APPD = $CMND_ALIAS_LIST
X			$RUNUSER ALL=(root) NOPASSWD: APPD
X		SUDOERS
X		chmod 0440 /etc/sudoers.d/appdynamics
X		echo "installed /etc/sudoers.d/appdynamics"
X	fi
X
X	if [ $use_cwrapper == 1 ] ; then
X		if require cc gcc gcc advise "to build $APPDSERVICE privilege escalation wrapper" ; then
X			# Clean up sudo privilege escalation if it was previously installed
X			rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X			# compile wrapper, chown and chmod with setuid
X			cc -D_GNU_SOURCE -DAPPDUSER=`id -u $RUNUSER` -o $APPDSERVICE appdservice.c
X			if [ -x $APPDSERVICE ] ; then
X				chown root:root $APPDSERVICE
X				chmod 4755 $APPDSERVICE
X				echo "installed setuid root wrapper as $APPDSERVICE"
X			else
X				echo "installation of $APPDSERVICE failed"
X			fi
X		else
X			echo "Exiting..."
X			exit 1
X		fi
X	fi
X
X	if [ $use_pbrun == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		# Install the pbrun privilege escalation wrapper
X		cp appdservice-pbrun.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed pbrun wrapper as $APPDSERVICE"
X	fi
X
X	if [ $use_xuser == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		# Install the xuser privilege escalation wrapper
X		cp appdservice-xuser.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed xuser wrapper as $APPDSERVICE"
X	fi
X
X	if [ $use_root == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		cp appdservice-root.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed root wrapper as $APPDSERVICE"
X	fi
X
X	if [[ `echo "cat //*[@port<1024]" | xmllint --shell $DOMAIN_XML | wc -l` -gt 1 ]] && \
X		! require setcap libcap libcap2-bin; then
X		echo "\
XERROR: AppDynamics is configured to bind to at least one port < 1024 as an
Xunprivileged user, but the setcap utility is not available on this host.
XAppDynamics will not run in the configuration."
X		exit 1
X	fi
Xfi
X
X#
X# install all
X#
Xi=0
Xfor s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X	install_init $s ${APPDYNAMICS_SERVICE_START[$i]} ${APPDYNAMICS_SERVICE_STOP[$i]}
X	((i++))
Xdone
END-of-install-init.sh
echo x - uninstall-init.sh
sed 's/^X//' >uninstall-init.sh << 'END-of-uninstall-init.sh'
X#!/bin/bash
X#
X# $Id: uninstall-init.sh 1.6 2015-12-23 00:36:28 cmayer $
X#
X# uninstall init script
X#
Xexport PATH=/sbin:/usr/sbin:$PATH
X
Xfunction remove() {
X	if rpm -qi --quiet $1 2>/dev/null; then return; fi	# skip if rpm package installed
X
X	if [ ! -f /etc/init.d/$1 ] ; then
X		return
X	fi
X	if [[ -x `which chkconfig 2>/dev/null` ]] ; then
X		chkconfig --del $1
X	elif [[ -x `which update-rc.d 2>/dev/null` ]] ; then
X		update-rc.d -f $1 remove
X	else
X		echo "Failed to remove $1: chkconfig or update-rc.d required"
X		exit 1
X	fi
X	echo removing $1 service
X	rm -f /etc/init.d/$1
X}
X
Xremove appdcontroller
Xremove appdcontroller-db
Xremove appdynamics-machine-agent
X
Xif [ -f /sbin/appdservice ] ; then
X	echo removing appdservice wrapper
X	rm -f /sbin/appdservice
Xfi
X
Xif [ -f /etc/sudoers.d/appdynamics ] ; then
X	echo removing appdynamics specific sudoers file
X	rm -f /etc/sudoers.d/appdynamics
X
X	if grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers ; then
X		echo removing sudoers additions
X		ex -s /etc/sudoers <<- RMAPPD
X			g/^#include[\t ][\t ]*\/etc\/sudoers.d\/appdynamics/d
X			wq
X		RMAPPD
X	fi
Xfi
END-of-uninstall-init.sh
echo x - appdservice.c
sed 's/^X//' >appdservice.c << 'END-of-appdservice.c'
X/*
X * $Id: appdservice.c 1.1 2015-06-12 12:22:17 cmayer $
X *
X * this program is a trampoline for the Appdynamics user to invoke
X * a controlled escalation of privilege to cause changes in the
X * installed appdynamics services via the system's service wrapper,
X * which is root-only
X *
X * security is ensured by only changing the enumerated services
X * and the enumerated funtions.  
X *
X * this file contains all the distro specific knowledge
X * it is intentionally coded in a brute-force manner to be trivially auditable
X *
X * all the source strings for the execv array are internal to this file, and
X * all the input arguments are only read using strcmp;  buffer overflows
X * are not possible.
X *
X * also, since we use execv, no path processing is done.
X */
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <unistd.h>
X#include <fcntl.h>
X
X/*
X * these names are intentionally not the same pointer, even though they have
X * the same value.
X * we never copy anything from the arguments to the exec arguments.
X */
Xstruct service {
X	char *name;
X	char *service_name;
X} services[] = {
X	{ "appdcontroller",		"appdcontroller" },
X	{ "appdcontroller-db",	"appdcontroller-db" },
X	{ "appdynamics-machine-agent", 	"appdynamics-machine-agent" }
X};
X#define NSRV (sizeof(services)/sizeof(services[0]))
X
X/* number of possible handlers */
X#define	NHAND	3
X
Xstruct action {
X	char *name;
X	struct handler {
X		char *prog;
X		char *verb;
X	} handlers[NHAND];
X} actions[] = {
X	{ "status", {
X		{ "service", "status" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "start", {
X		{ "service", "start" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "stop", {
X		{ "service", "stop" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "enable", {
X		{ "chkconfig", "on" },
X		{ "update-rc.d", "enable" },
X		{ 0, 0 }}
X	},
X	{ "disable", {
X		{ "chkconfig", "off" },
X		{ "update-rc.d", "disable" },
X		{ 0, 0 }}
X	}
X};
X#define NACT (sizeof(actions)/sizeof(actions[0]))
X
X/*
X * the complete list of directories for lookup of commands
X */
Xchar *bindirs[] = {
X	"/sbin", "/usr/sbin", 0
X};
X
Xvoid
Xusage(char *pname)
X{
X	int i, j;
X
X	fprintf(stderr, "usage: %s <service> <action>\n", pname);
X	for (i = 0; i < NSRV; i++) {
X		fprintf(stderr, "\t%s {", services[i].name);
X		for (j = 0; j < NACT; j++) {
X			fprintf(stderr, "%s", actions[j].name);
X			if (j < NACT - 1) {
X				fprintf(stderr, ",");
X			}
X		}
X		fprintf(stderr, "}\n");
X	}
X	exit (1);
X}
X
X/*
X * return zero if the program is executable in the specified directory
X */
Xint
Xexecutable_at(char *dir, char *prog)
X{
X	int dirfd;
X	int ret;
X
X	dirfd = open(dir, O_RDONLY | O_DIRECTORY);
X	ret = faccessat(dirfd, prog, AT_EACCESS, X_OK);
X	close(dirfd);
X	return (ret);
X}
X
Xchar *argvec[4];
Xchar *progpath;
X
Xint
Xmain(int argc, char**argv)
X{
X	char cmdbuf[80];
X	int svc;
X	int act;
X	int hand;
X	char *prog;
X	char *dir;
X	
X	if (argc != 3) {
X		usage(argv[0]);
X		exit (1);
X	}
X
X	/* look up service */
X	for (svc = 0; svc < NSRV; svc++) {
X		if (strcmp(services[svc].name, argv[1]) == 0) {
X			break;
X		}
X	}
X	if (svc >= NSRV) {
X		fprintf(stderr, "unknown service %s\n", argv[1]);
X		usage(argv[0]);
X	}
X
X	/* look up action */
X	for (act = 0; act < NACT; act++) {
X		if (strcmp(actions[act].name, argv[2]) == 0) {
X			break;
X		}
X	}
X	if (act >= NACT) {
X		fprintf(stderr, "unknown action %s\n", argv[2]);
X		usage(argv[0]);
X	}
X
X	/* validate that we are either the appdynamics user or root */
X	if (getuid() != APPDUSER && getuid() != 0) {
X		fprintf(stderr, "must be run as user id %d or root\n", APPDUSER);
X		exit(2);
X	}
X
X	/* validate that we are effectively root */
X	if (geteuid() != 0) {
X		fprintf(stderr, "must be run setuid root\n");
X		exit(3);
X	}
X	
X	/* definitively become root */
X	setreuid(0, 0);
X	setregid(0, 0);
X
X	/* iterate through handlers until null */
X	for (hand = 0; prog = actions[act].handlers[hand].prog; hand++) {
X
X		/* search the bindirs */
X		for (dir = bindirs[0]; dir; dir++) {
X
X			/* if we can run it, do so */
X			if (executable_at(dir, prog)) {
X
X				progpath = malloc(strlen(dir) + strlen(prog) + 2);
X				strcpy(progpath, dir);
X				strcat(progpath, "/");
X				strcat(progpath, prog);
X				argvec[0] = strdup(prog);
X				argvec[1] = strdup(services[svc].service_name);
X				argvec[2] = strdup(actions[act].handlers[hand].verb);
X				argvec[3] = 0;
X
X				execv(progpath, argvec);	
X			}
X		}
X	}
X
X	fprintf(stderr, "no valid handlers found for service %s action %s\n",
X		services[svc].name, actions[act].name);
X	exit(4);
X}
END-of-appdservice.c
echo x - appdservice-pbrun.sh
sed 's/^X//' >appdservice-pbrun.sh << 'END-of-appdservice-pbrun.sh'
X#!/bin/bash
X#
X# $Id: appdservice-pbrun.sh 1.1 2015-12-23 00:36:28 cmayer $
X#
X# shell wrapper around pbrun for appdynamics service changes
X#
XPBRUN=/usr/local/bin/pbrun
X
Xfunction usage {
X	echo usage: "$0 [appdcontroller|appdcontroller-db|appdynamics-machine-agent start|stop|status]"
X	exit 1
X}
X
Xif [ ! -x $PBRUN ] ; then
X	echo $0: pbrun not found at $PBRUN
X	exit 2
Xfi
X
Xif [ $# -ne 2 ] ; then
X	usage
Xfi
X
Xcase $1 in
X	appdcontroller|appdcontroller-db|appdynamics-machine-agent)
X		service=$1
X		;;
X	*)
X		usage
X		;;
Xesac
X
Xcase $2 in
X	start|stop|status)
X		action=$2
X		;;
X	*)
X		usage
X		;;
Xesac
X
X$PBRUN -p -b /sbin/service $service $action
Xexit 0
END-of-appdservice-pbrun.sh
echo x - appdservice-root.sh
sed 's/^X//' >appdservice-root.sh << 'END-of-appdservice-root.sh'
X#!/bin/bash
X#
X# $Id: appdservice-root.sh 1.1 2015-12-23 00:36:28 cmayer $
X#
X# shell wrapper around service for service changes - designed to run as root
X#
Xfunction usage {
X	echo usage: "$0 [appdcontroller|appdcontroller-db|appdynamics-machine-agent start|stop|status]"
X	exit 1
X}
X
Xif [ $# -ne 2 ] ; then
X	usage
Xfi
X
Xcase $1 in
X	appdcontroller|appdcontroller-db|appdynamics-machine-agent)
X		service=$1
X		;;
X	*)
X		usage
X		;;
Xesac
X
Xcase $2 in
X	start|stop|status)
X		action=$2
X		;;
X	*)
X		usage
X		;;
Xesac
X
X/sbin/service $service $action
Xexit 0
END-of-appdservice-root.sh
echo x - appdservice-xuser.sh
sed 's/^X//' >appdservice-xuser.sh << 'END-of-appdservice-xuser.sh'
X#!/bin/bash
X#
X# $Id: appdservice-xuser.sh 1.1 2015-12-23 00:36:28 cmayer $
X#
X# user defined shell wrapper for appdynamics service changes
X#
X
Xfunction usage {
X	echo usage: "$0 [appdcontroller appdcontroller-db] [start stop status]"
X	exit 1
X}
X
Xif [ $# -ne 2 ] ; then
X	usage
Xfi
X
Xcase $1 in
X	appdcontroller|appdcontroller-db)
X		service=$1
X		;;
X	*)
X		usage
X		;;
Xesac
X
Xcase $2 in
X	start|stop|status)
X		action=$2
X		;;
X	*)
X		usage
X		;;
Xesac
X
X#
X# insert user state change handler code
X# use $service and $action
X#
Xexit 0
END-of-appdservice-xuser.sh
echo x - appdynamics-machine-agent.old.sh
sed 's/^X//' >appdynamics-machine-agent.old.sh << 'END-of-appdynamics-machine-agent.old.sh'
X#!/bin/bash 
X# 
X# $Id: appdynamics-machine-agent.old.sh 1.1 2016-03-25 11:48:18 rob.navarro $
X#
X# Init file for AppDynamics Machine Agent 
X# 
X# chkconfig: 2345 60 25 
X# description: machine agent for AppDynamics
X### BEGIN INIT INFO
X# Provides:          appdynamics-machine-agent
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Required-Start:
X# Required-Stop:
X# Short-Description: AppDynamics Machine Agent
X# Description:       Enable AppDynamics Machine Agent service provided by daemon.
X### END INIT INFO
X
X# Setting PATH to just a few trusted directories is an **important security** requirement
XPATH=/bin:/usr/bin:/sbin:/usr/sbin
X
XAPPD_ROOT=/opt/AppDynamics/Controller
XJAVA_HOME=$APPD_ROOT/jre
X
X#CHANGE ME: Set to the agent's install directory 
XMACHINE_AGENT_HOME="/opt/AppDynamics/MachineAgent"
X
X# CHANGE ME: Set to the machine agent runtime user
X# If not running the machine agent as root, we recommend running as
X# the same user ID as other applications you are monitoring with
X# AppDynamics
XMACHINE_AGENT_USER=root
X
X# Agent Options 
XAGENT_OPTIONS="" 
XAGENT_OPTIONS="$AGENT_OPTIONS -Dappdynamics.agent.runtime.dir=$MACHINE_AGENT_HOME"
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dappdynamics.agent.applicationName=<application-name>" 
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dappdynamics.agent.logging.dir=" 
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dmetric.http.listener=true | false 
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dmetric.http.listener.port=<port>" 
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dserver.name=<hostname>" 
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dappdynamics.agent.tierName=<tiername>"
X#AGENT_OPTIONS="$AGENT_OPTIONS -Dappdynamics.agent.nodeName=<nodename>"
X
X# Derived Constants
XJAVA=$JAVA_HOME/bin/java
XAGENT="$MACHINE_AGENT_HOME/machineagent.jar"
X
X# Process management constants.
X# Do not change unless you are certain of what you are doing.
XNAME=$(basename $(readlink -e $0))
XPIDFILE=/var/run/$NAME.pid
XLOCKFILE=/var/lock/subsys/$NAME
X
Xif [ `id -un` == $MACHINE_AGENT_USER ] ; then
X        function bg_runuser {
X                exec nohup $* >/dev/null 2>&1 & echo $!
X        }
X        function runuser {
X                $*
X        }
Xelse
X        function bg_runuser {
X                su -c "exec nohup $* >/dev/null 2>&1 & echo \$!" $MACHINE_AGENT_USER
X        }
X        function runuser {
X                su -c "$*" $MACHINE_AGENT_USER
X        }
Xfi
X
X_status(){
X	local realPID
X	local otherPIDs
X	local returnvalue
X
X	realPID=$(cat $PIDFILE 2>/dev/null)
X	otherPIDs=( $(pgrep -f '^/?(.*/)?java ?.* -jar /?(.*/)?machineagent.jar($| .*$)' | grep -vw "$realPID") )
X
X	if ps -p $realPID >/dev/null 2>&1 ; then
X		returnvalue=0;
X	else
X		if [ -f $PIDFILE ] ; then
X			returnvalue=1
X		elif [ -f $LOCKFILE ] ; then
X			returnvalue=2
X		else
X			returnvalue=3
X		fi
X	fi
X
X	if [ "${#otherPIDs[@]}" -gt 0 ] ; then
X		echo "\
XWARNING: One or more instances of the AppDynamics machine agent are running
Xoutside of this wrapper"
X		ps -p ${otherPIDs[@]}
X	fi
X
X	return $returnvalue
X}
X
X
Xstart() 
X{
X    if ! _status ; then
X		local PID
X		PID=`bg_runuser $JAVA $AGENT_OPTIONS -Xmx32m -jar $AGENT`
X		echo $PID > $PIDFILE
X
X		# if the machine agent is going to die an early death due to
X		# misconfiguration, it will take about 20 seconds
X		sleep 20
X
X		if ps -p $PID >/dev/null 2>&1 ; then
X			touch $LOCKFILE
X		else
X			rm -f $PIDFILE
X			echo "ERROR: failed to start $NAME"
X			return 7
X		fi
X	else
X		echo "\
XAppDynamics machine agent already running and wrapped by
X$(readlink -e $0)"
X		return 0
X	fi
X}
X
Xstop() 
X{
X	local returnvalue
X	local status
X	_status
X	status=$?
X	if [ -f $LOCKFILE ] ; then
X		if [ $status == 0 ] ; then
X			kill -9 $(cat $PIDFILE)
X			returnvalue=0
X		else
X			returnvalue=7
X		fi
X		rm -f $PIDFILE
X		rm -f $LOCKFILE
X	else
X		echo "\
XAppDynamics machine agent not running under
X$(readlink -e $0)"
X	fi
X	return $returnvalue
X}
X
X
Xcase "$1" in 
X	start) 
X		start
X		exit $?
X	;; 
X	status) 
X     	_status
X		exitcode=$?
X		if [ "$exitcode" == 0 ] ; then
X			echo "\
XAppDynamics machine agent running and wrapped by
X$(readlink -e $0)"
X		else
X			echo "\
XAppDynamics machine agent not running under
X$(readlink -e $0)"
X		fi
X		exit $exitcode
X	;;
X	stop) 
X	    stop
X		exit $?
X	;; 
X
X	restart) 
X	    stop 
X	    start 
X	;; 
X*) 
X     echo "Usage: $0 start|stop|restart" 
Xesac
END-of-appdynamics-machine-agent.old.sh
echo x - appdynamics-machine-agent.old.sysconfig
sed 's/^X//' >appdynamics-machine-agent.old.sysconfig << 'END-of-appdynamics-machine-agent.old.sysconfig'
X#!/bin/sh
X#
X# $Id: appdynamics-machine-agent.old.sysconfig 1.1 2016-03-25 11:48:18 rob.navarro $
X#
XMACHINE_AGENT_HOME=/opt/appdynamics/machine-agent
XAPPD_ROOT=/opt/appdynamics/Controller
XJAVA_HOME=$APPD_ROOT/jre
XMACHINE_AGENT_USER=root
XJAVA_OPTS="-Xmx512m -Xms512m"
Xexport JAVA_OPTS MACHINE_AGENT_USER JAVA_HOME MACHINE_AGENT_HOME
END-of-appdynamics-machine-agent.old.sysconfig
echo x - appdynamics-machine-agent.sh
sed 's/^X//' >appdynamics-machine-agent.sh << 'END-of-appdynamics-machine-agent.sh'
X#!/bin/sh
X#
X# $Id: appdynamics-machine-agent.sh 1.1 2016-03-25 11:48:18 rob.navarro $
X#
X# /etc/init.d/appdynamics-machine-agent
X#
X# This file describes the machine agent service. Copy it or place it in /etc/init.d to ensure the machine
X# agent is started as a service. If you installed the machine agent via an RPM or DEB package, it should
X# already be placed there.
X#
X# Copyright (c) 2014 AppDynamics Inc
X# All rights reserved
X#
X# chkconfig: 2345 95 05
X# description: AppDynamics Machine Agent
X# processname: MachineAgent
X# config: /etc/appdynamics/machine-agent/controller-info.xml
X# config: /etc/appdynamics/machine-agent/logging/log4j.xml
X# config: /etc/sysconfig/appdynamics-machine-agent
X# pidfile: /var/run/appdynamics-machine-agent
X#
X### BEGIN INIT INFO
X# Provides:          appdynamics-machine-agent
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Required-Start:
X# Required-Stop:
X# Short-Description: AppDynamics Machine Agent
X# Description:       Enable AppDynamics Machine Agent service provided by daemon.
X### END INIT INFO
X
X# Setting PATH to just a few trusted directories is an **important security** requirement
XPATH=/bin:/usr/bin:/sbin:/usr/sbin
X
Xprog="appdynamics-machine-agent"
Xpidfile="/var/run/appdynamics/$prog"
Xlockfile="/var/lock/subsys/$prog"
X
X# Defaults. Do not edit these. They will be overwritten in updates.
X# Override in /etc/sysconfig/appdynamics-machine-agent
XMACHINE_AGENT_HOME=/opt/appdynamics/machine-agent
XJAVA_HOME=$MACHINE_AGENT_HOME/jre
XMACHINE_AGENT_USER=root
X
X# source script config
X[ -f /etc/sysconfig/appdynamics-machine-agent ] && . /etc/sysconfig/appdynamics-machine-agent
X[ -f /etc/default/appdynamics-machine-agent ] && . /etc/default/appdynamics-machine-agent
X
X# source function library (distribution-dependedent)
Xif [ -f /etc/rc.d/init.d/functions ]; then
X    # redhat flavor
X    . /etc/rc.d/init.d/functions
X    start_cmd="daemon --pidfile $pidfile --user $MACHINE_AGENT_USER"
X    status_cmd="status -p $pidfile $prog"
Xelif [ -f /lib/lsb/init-functions ]; then
X    # debian flavor
X    . /lib/lsb/init-functions
X    start_cmd="start_daemon -p $pidfile"
X    status_cmd="status_of_proc -p $pidfile $prog $prog"
Xelse
X    echo "Unable to find function library" 1>&2
X    exit 1
Xfi
Xstop_cmd="killproc -p $pidfile $prog"
X
XRETVAL=0
X
Xcheckroot() {
X    # Check to see if we're running this script as root or sudo
X    if [ `id -u` -ne 0 ]; then
X        echo "This script must be run as sudo or root" 1>&2
X        exit 1
X    fi
X}
X
Xstart() {
X    # make sure needed dirs are there
X    mkdir -p /var/run/appdynamics
X    chown $MACHINE_AGENT_USER /var/run/appdynamics
X    mkdir -p /var/lock/subsys
X
X    checkroot
X    echo -n $"Starting $prog:"
X    JAVA_HOME=$JAVA_HOME $start_cmd $MACHINE_AGENT_HOME/bin/machine-agent -d -p $pidfile
X    RETVAL=$?
X    [ "$RETVAL" = 0 ] && touch $lockfile
X    echo
X}
X
Xstop() {
X    checkroot
X    echo -n $"Stopping $prog:"
X    $stop_cmd
X    RETVAL=$?
X    [ "$RETVAL" = 0 ] && rm -f $lockfile
X    echo
X}
X
Xcase "$1" in
X    start)
X        start
X        ;;
X    stop)
X        stop
X        ;;
X    restart)
X        if [ -f /var/lock/subsys/$prog ] ; then
X            stop
X            # avoid race
X            sleep 3
X            start
X        fi
X        ;;
X    status)
X        $status_cmd
X        RETVAL=$?
X        ;;
X    *)    (10)
X        echo $"Usage: $0 {start|stop|restart|status}"
X        RETVAL=1
Xesac
Xexit $RETVAL
END-of-appdynamics-machine-agent.sh
echo x - appdynamics-machine-agent.sysconfig
sed 's/^X//' >appdynamics-machine-agent.sysconfig << 'END-of-appdynamics-machine-agent.sysconfig'
X#!/bin/sh
X#
X# $Id: appdynamics-machine-agent.sysconfig 1.1 2016-03-25 11:48:18 rob.navarro $
X#
XMACHINE_AGENT_HOME=/opt/appdynamics/machine-agent
XJAVA_HOME=$MACHINE_AGENT_HOME/jre
XMACHINE_AGENT_USER=root
XJAVA_OPTS="-Xmx512m -Xms512m"
Xexport JAVA_OPTS MACHINE_AGENT_USER JAVA_HOME MACHINE_AGENT_HOME
END-of-appdynamics-machine-agent.sysconfig
echo x - hafunctions.sh
sed 's/^X//' >hafunctions.sh << 'END-of-hafunctions.sh'
X#!/bin/bash
X#
X# $Id: hafunctions.sh 1.3 2016-05-17 22:48:38 rob.navarro $
X#
X# hafunctions.sh
X# contains common code used by the HA toolkit
X# 
X###############################################################################
X#
X# IMPORTANT - 	add function names to "export -f" list at bottom of this file
X#              	that should be callable by sub-shells. Any function not so added
X#	 	will not be visible to any sub-shells e.g. $(...), pipelines etc.
X#
X###############################################################################
X
Xfunction err {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "ERROR: $PROGNAME: $*" 1>&2
X        exit 1
X}
X
Xfunction warn {
X	local PROGNAME=${0##*/}
X	local PROGSTEM=${PROGNAME%%.*}
X        echo "WARNING: $PROGNAME: $*" 1>&2
X}
X
X# Helper function to entirely encapsulate variable substitution logic applied to Init
X# scripts during installation.
X# Uses global variables: APPD_ROOT RUNUSER MA_install_dir
X# Call as:
X#   convert_init_script $infile > $outfile
Xfunction convert_init_script {
X        (( $# == 1 )) || err "convert_init_script: needs 1 arg"
X        local infile=$1
X
X        [[ -f $infile ]] || err "convert_init_script: unable to read '$infile'"
X        sed < $infile \
X                -e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X                -e "/^RUNUSER=/s,=.*,=$RUNUSER," \
X                -e "/^MACHINE_AGENT_HOME=/s,=.*,=$MA_install_dir,"
X}
X
X#
X# Collection of routines to deal with MySQL root password
X#
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa1 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa1 <data>
Xfunction obf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(tr '\!-~' 'P-~\!-O' < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 obfuscation"
X	obf=$(base64 -w 0 < <(echo -n $step1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa1 <data>
Xfunction deobf_ofa1 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X	which base64 >& /dev/null || err "$thisfn needs \'base64\'"
X
X	step1=$(base64 -d -w 0 < <(echo -n $1)) || exit 1
X	[[ -n "$step1" ]] || err "$thisfn produced empty step1 deobfuscation"
X	clear=$(tr '\!-~' 'P-~\!-O' < <(echo -n $step1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  ofa2 <obfuscated value of input parameter>
X#
X# Call as:
X#  obf_ofa2 <data>
Xfunction obf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <clear_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 otype obf
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	obf=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$obf" ]] || err "$thisfn produced empty obfuscation"
X
X	# use part of function name after last '_' as obfuscator type
X	echo "${thisfn##*_} "$obf
X}
X
X# one of pair of low level functions {obf,deobf}_<some extention>
X# Expected to output to STDOUT:
X#  <deobfuscated value of input parameter>\n
X# Call as:
X#  deobf_ofa2 <data>
Xfunction deobf_ofa2 {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} step1 clear
X	which tr >& /dev/null || err "$thisfn needs \'tr\'"
X
X	clear=$(tr 'A-Za-z' 'N-ZA-Mn-za-m' < <(echo -n $1)) || exit 1
X	[[ -n "$clear" ]] || err "$thisfn produced empty cleartext"
X
X	echo $clear
X}
X
X# overall wrapper function for obfuscation 
X# Call as
X#  obfuscate <obf type> <data>
X# or
X#  obfuscate <data>
Xfunction obfuscate {
X	(( $# == 1 || $# == 2 )) || err "Usage: ${FUNCNAME[0]} [<obf type>] <data>"
X
X	local thisfn=${FUNCNAME[0]} data otype
X	if (( $# == 2 )) ; then
X		otype=$1
X		data=$2
X	else
X		otype=''
X		data=$1
X	fi
X	case $otype in
X		ofa1 | '' )	obf_ofa1 $data ;;	# default case
X		ofa2)		obf_ofa2 $data ;;
X		*)		err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X# overall wrapper for various de-obfuscator functions
X# Call as:
X#  deobfuscate <otype> <obf_data>
Xfunction deobfuscate {
X	(( $# == 2 )) || err "Usage: ${FUNCNAME[0]} <obf type> <obf_data>"
X
X	local thisfn=${FUNCNAME[0]} otype=$1 data=$2
X	case $otype in
X		ofa1)	deobf_ofa1 "$data" ;;
X		ofa2)	deobf_ofa2 "$data" ;;
X		*)	err "$thisfn: unknown obfuscation type \"$otype\"" ;;
X	esac
X}
X
X###
X
X# with help from:
X# http://stackoverflow.com/questions/1923435/how-do-i-echo-stars-when-reading-password-with-read
Xfunction getpw { 
X        (( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <variable name>"
X        local pwch inpw1 inpw2=' ' prompt; 
X        
X        ref=$1 
X	while [[ "$inpw1" != "$inpw2" ]] ; do
X		prompt="Enter MySQL root password: "
X		inpw1=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw1+=$pwch 
X			fi 
X		done 
X
X		prompt="re-enter same password: "
X		inpw2=''
X		while read -p "$prompt" -r -s -n1 pwch ; do 
X			if [[ -z $pwch ]]; then 
X				echo > /dev/tty
X				break 
X			else 
X				prompt='*'
X				inpw2+=$pwch 
X			fi 
X		done 
X	
X		[[ "$inpw1" == "$inpw2" ]] || echo "passwords unequal. Retry..." 1>&2
X	done
X
X	# indirect assignment (without local -n) needs eval. 
X	# This only works with global variables :-( Please use weird variable names to
X	# avoid namespace conflicts...
X        eval "${ref}=\$inpw1"            # assign passwd to parameter variable
X}
X
X# helper function to allow separate setting of passwd from command line.
X# Use this to persist an obfuscated version of the MySQL passwd to disk.
X# Call as:
X#  . hafunctions.sh
X#  save_mysql_passwd $APPD_ROOT
Xfunction save_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	getpw __inpw1 || exit 1		# updates __inpw1 *ONLY* if global variable
X	obf=$(obfuscate $__inpw1) || exit 1
X	echo $obf > $rootpw_obf || err "$thisfn: failed to save obfuscated passwd to $rootpw_obf"
X	chmod 600 $rootpw_obf || warn "$thisfn: failed to make $rootpw_obf readonly"
X}
X
X# get MySQL root password in a variety of ways. Implement the concept:
X# 1. respect MYSQL_ROOT_PASSWD if present; please pass down to sub-scripts. Do NOT persist to disk.
X# 2. respect $APPD_ROOT/db/.rootpw if present
X# 3. respect $APPD_ROOT/db/.rootpw.obf if present
X# 4. otherwise get MySQL root passwd from command line, obfuscate and persist to $APPD_ROOT/db/.rootpw.obf
X#
X# Call as:
X#  $dbpasswd=$(get_mysql_passwd $APPD_ROOT) || exit 1
Xfunction get_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	local thisfn=${FUNCNAME[0]} APPD_ROOT=$1 clear obf otype inpw2=' '
X	[[ -d $1 ]] || err "$thisfn: \"$1\" is not APPD_ROOT"
X	local rootpw="$APPD_ROOT/db/.rootpw" rootpw_obf="$APPD_ROOT/db/.rootpw.obf"
X
X	if [[ -n "$MYSQL_ROOT_PASSWD" ]] ; then
X		echo $MYSQL_ROOT_PASSWD
X	elif [[ -s $rootpw && -r $rootpw ]] ; then 
X		echo $(<$rootpw)
X	elif [[ -s $rootpw_obf ]] ; then
X		IFS=$' ' read -r otype obf < $rootpw_obf
X		[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X		clear=$(deobfuscate $otype $obf) || exit 1
X		[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X		echo $clear
X	else
X		# if STDIN/STDOUT open & connected to a terminal - ie not run as a service, daemon or over ssh
X		if [[ -t 0 && -t 1 ]] ; then
X			save_mysql_passwd $APPD_ROOT			# but save writes directly to disk 
X			IFS=$' ' read -r otype obf < $rootpw_obf	# so need to read back in...
X			[[ -n "$otype" && -n "$obf" ]] || err "$thisfn: unable to read obfuscated passwd from $rootpw_obf"
X			clear=$(deobfuscate $otype $obf) || exit 1
X			[[ -n "$clear" ]] || err "$thisfn: unable to deobfuscate passwd from $rootpw_obf"
X			echo $clear
X		else				# give up with an error
X			local RUNUSER=$(awk -F= '$1=="user" { print $2  }' $APPD_ROOT/db/db.cnf)
X			[[ -n "$RUNUSER" ]] || RUNUSER=MySQL
X			err "$thisfn: unable to get MySQL root passwd. As $RUNUSER user run \"(cd HA;. hafunctions.sh;save_mysql_passwd \$(pwd)/..)\" interactively and try again."
X		fi
X	fi
X}
X
X# because there is currently no single program guaranteed to run before using the other scripts
X# we need each script to be able to check whether MySQL root passwd has been set or not.
X# LATER: This can be fixed in future with a self-extracting archive that includes install logic. 
X# Call as:
X#  check_for_mysql_passwd $APPD_ROOT || exit 1
Xfunction check_for_mysql_passwd {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <APPD_ROOT>"
X
X	get_mysql_passwd $1 >/dev/null 
X}
X
X# make-do function that ignores junk header of controller.sh login-db output that precedes the
X# actual mysql client output and outputs the 1 chosen line requested. This became necessary
X# as folk chose to follow mysql client output with extraneous newline. 
X# Replace 'controller.sh login-db | tail -1' with 'controller.sh login-db | getsqlrow 2'
X# Will be obsolete once clean mysql client output is provided.
X#
X# Call as:
X#  SQLval=$(bin/controller.sh login-db | getsqlrow 2)
Xfunction getsqlrow {
X	(( $# == 1 )) && [[ $1 =~ ^[[:digit:]]+$ ]] || err "Usage: ${FUNCNAME[0]} <mysql client output row #>" || exit 1
X
X   	local LINE pattern='^Logging into the controller database' skiprows
X   	while read -r LINE ; do
X		if [[ $LINE =~ $pattern ]] ; then
X			for (( skiprows=1; skiprows<=$1; ++skiprows )); do 
X				IFS= read -r LINE || return
X	   		done
X	   		echo $LINE		# or preserve leading whitespace with "$LINE"
X			return
X		fi
X   	done
X}
X
X# replacement for calling 'controller.sh login-db' that is guaranteed to only output what 
X# underlying mysql client does. This makes it much easier to reliably parse.
X# Call as:
X#  VAL=$(echo "some SQL" | mysqlclient $APPD_ROOT | grep -q "active")
Xfunction mysqlclient {
X	(( $# == 1 )) || err "Usage: ${FUNCNAME[0]} <controller install directory>"
X
X	local APPD_ROOT=$1
X	[[ -n "$MYSQL_ROOT_PASSWD" ]] || MYSQL_ROOT_PASSWD=$(get_mysql_passwd $APPD_ROOT) || exit 1
X  	[[ -n "$DB_PORT" ]] || DB_PORT=$(awk -F= '$1=="port" { print $2  }' $APPD_ROOT/db/db.cnf) || exit 1
X	[[ -n "$DB_PORT" ]] || err "${FUNCNAME[0]}: unable to read MySQL port number from $APPD_ROOT/db/db.cnf"
X
X	$APPD_ROOT/db/bin/mysql -A -u root -p"${MYSQL_ROOT_PASSWD}" --port=$DB_PORT --protocol=TCP controller
X}
X
X###############################################################################
X#
X# FOOTER block
X#
X# IMPORTANT  - add function names here which should be callable by sub-shells
X#
X###############################################################################
Xexport -f err warn getpw obf_ofa1 obf_ofa2 obfuscate
Xexport -f mysqlclient get_mysql_passwd save_mysql_passwd deobfuscate deobf_ofa1 deobf_ofa2
X
END-of-hafunctions.sh
echo x - mysqlclient.sh
sed 's/^X//' >mysqlclient.sh << 'END-of-mysqlclient.sh'
X#!/bin/bash
X
X#
X# $Id: mysqlclient.sh 1.1 2016-05-18 22:52:38 rob.navarro $
X#
X
X# mini wrapper for shell function that provides a passwordless mysql client.
X# That it lives on disk is useful for ssh calls where functions do not
X# automatically get loaded.
X# Intended as a direct replacement for the '$APPD_ROOT/bin/controller.sh login-db'
X# No frivolous output and respects any of the 3 password storage options.
X
X# controller install directory
XAPPD_ROOT=$(cd $(dirname "$0"); cd .. ; pwd -P)
X
X# source function library
XFUNCLIB="$APPD_ROOT/HA/hafunctions.sh"
Xif [[ -f "$FUNCLIB" ]] ; then
X        #shldignore             # stop Makefile trying to embed the next source file
X        . $FUNCLIB
Xelse
X        echo "ERROR: unable to find function library '$FUNCLIB'" 1>&2
X        exit 1
Xfi
X
Xmysqlclient $APPD_ROOT
END-of-mysqlclient.sh
echo x - RUNBOOK
sed 's/^X//' >RUNBOOK << 'END-of-RUNBOOK'
XThe HA environment can be in several states, and it is desireable to place 
Xthe systems into the fully replicated state as soon as possible. here are
Xthe possible states, how to identify the state, and the corresponding 
Xprocedure to repair the condition.
X
X-----------
XNOT PRESENT:
X	the HA package has not been installed on the primary machine.
X
Xdiagnosis:
X	the HA directory is absent from the controller directory.
X
Xto fix:
X	cd <controller root> ; mkdir HA ; cd HA ; bash <path>/HA.shar
X	then follow the steps for UNINSTALLED
X
X-----------
XUNINSTALLED:
X	the package is present in the controller HA directory, but the
X	services have not been installed.
X
Xdiagnosis:
X	service appdcontroller status shows appdcontroller service not found
X
Xto fix:
X	cd <controller root>/HA
X	become root
X	./install-init.sh [-c | -s]
X
X------------
XNO HOSTS:
X	the secondary machine does not have a resolvable host name
X
Xdiagnosis:
X	ping <secondary> returns unknown host
X
Xto fix:
X	add the primary and secondary host name into both machines /etc/hosts files
X	
X------------
XNO SSH:
X	the appdynamics user does not have no-password ssh access between
X	machines.
X
Xdiagnosis:
X	ssh <secondary> date prompts for a password
X
Xto fix:
X	in the below, you will be prompted for passwords and confirmations
X	ssh-keygen -P "" -f ~/.ssh/id_rsa -t rsa
X	ssh <secondary> ssh-keygen -P "''" -f ~/.ssh/id_rsa -t rsa
X	scp ~/.ssh/id_rsa.pub <secondary>:.ssh/authorized_keys
X	scp <secondary>:.ssh/id_rsa.pub ~/.ssh/authorized_keys
X
X------------
XUNREPLICATED: the HA package has been installed on the primary controller,
Xbut the package has not been activated.
X
Xdiagnosis:
X	service appdcontroller-db status shows "HA not installed" 
X
Xto fix:
X	cd <controller root>/HA
X	./replicate -s <secondary>
X	<become root on secondary>
X		cd <controller root>/HA
X		./install-init [-c | -s]
X		exit
X	<back on primary>
X	./replicate -s <secondary> -e <vip>	-f
X		confirm
X
X----------
XDISCONNECTED:
XReplication communication is being blocked, HA has been installed and activated,
Xbut a firewall is preventing access to replication communications.
X
Xdiagnosis:
X	service appdcontroller-db status shows 
X		"Slave_IO_State: Connecting to master"
X		"Seconds_Behind_Master: NULL"
X
Xto fix:
X	disable the firewall for port 3388
X	brute force as root:  iptables -F
X
X----------
XREPLICATED, WATCHDOG RUNNING: 
Xthe HA package is running fully replicated, and the primary node is serving
Xagents with metric storage, and the UI is responsive.  the secondary is
Xmonitoring the primary appserver with a watchdog process.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
X	service appdcontroller status on the secondary reports:
X	db running as <user> - passive
X	secondary
X		Slave_IO_State: Waiting for master to send event
X	watchdog running
X
Xto fix:
X	nothing to fix
X
X----------
XREPLICATED, WATCHDOG NOT RUNNING: 
Xthe HA package is running fully replicated, and the primary node is serving
Xagents with metric storage, and the UI is responsive.  the secondary is
Xnot monitoring the primary appserver with a watchdog process.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
X	service appdcontroller status on the secondary reports:
X	db running as <user> - passive
X	secondary
X		Slave_IO_State: Waiting for master to send event
X	watchdog not running
X
Xto fix:
X	on the secondary
X	cd <controller root>/HA
X	touch WATCHDOG_ENABLE
X	/sbin/appdservice appdcontroller start
X
X---------
XFAILED OVER, old primary broken
XThe current active node has become active because of a failover.  the prior
Xactive node's database is inaccessible.  the assassin is running on the new
Xactive node to mark the old active node passive once it comes up.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	secondary
X		Slave_IO_State:
X		Seconds_Behind_Master: NULL
X	assassin running
X
Xto fix:
X	replicate from the new active node to the old active node using
X	the formula for UNREPLICATED
X
X------------
XFAILED OVER, watchdog running
XThe current active node has become active because of a failover.  the prior
Xactive node database is still intact, and replication is valid. the new
Xsecondary node has a watchdog running.  this is identical to the REPLICATED,
XWATCHDOG_RUNNING state.
X
Xdiagnosis:
X	service appdcontroller status on the original primary reports:
X	db running as <user> - passive
X		Slave_IO_State: Waiting for master to send event
X	secondary
X	watchdog running
X
X	service appdcontroller status on the original secondary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
Xto-fix:
X	no need to fix anything.  should it be desired to make the original node
X	the active node:
X
X	on the original primary,
X	cd <controller root>/HA
X	./failover.sh
X
X-------------
XPASSIVE DOWN
Xthis is a state deliberately caused to perform a consistent backup of the
Xdatabase.   it is initiated on the passive node by running:
X/sbin/appdservice appdcontroller-db stop
X
Xdiagnosis:
X	/sbin/appdservice appdcontroller-db status on the passive node reports:
X	db not running
X
Xto-fix:
X	on the passive controller,
X	/sbin/appdservice appdcontroller start
X
X-------------
XERROR: bash: get_mysql_passwd: unable to get MySQL root passwd. As appdyn user run "(cd HA;. hafunctions.sh;save_mysql_passwd $(pwd)/..)" interactively and try again.
X
Xdiagnosis:
X	A stored MySQL root password, obfuscated or clear has not been found. Storing the 
X	MySQL root password to disk is a requirement for the HA Toolkit running with
X	service which in turn needs privilege escalation eg /sbin/appdservice or sudo or pbrun
X
Xto-fix:
X	> on the server as the intended AppD user (here "appdyn"):
X	(cd HA;. hafunctions.sh;save_mysql_passwd $(pwd)/..)
X	> this will persist the password after obfuscating it
X
XVersion:
X--------
X$Id: RUNBOOK 1.3 2016-05-17 22:35:27 rob.navarro Exp $
X
END-of-RUNBOOK
chmod ugo+rx . .. *.sh; exit

